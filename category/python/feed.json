{
    "version": "https://jsonfeed.org/version/1",
    "title": "Hexo • All posts by \"python\" category",
    "description": "",
    "home_page_url": "https://nnnpc.github.io",
    "items": [
        {
            "id": "https://nnnpc.github.io/2024/04/16/%E4%B8%BB%E5%8A%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E2%80%94%E2%80%94%E7%B3%BB%E7%BB%9F%E8%AF%86%E5%88%AB/",
            "url": "https://nnnpc.github.io/2024/04/16/%E4%B8%BB%E5%8A%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E2%80%94%E2%80%94%E7%B3%BB%E7%BB%9F%E8%AF%86%E5%88%AB/",
            "title": "主动信息收集------系统识别",
            "date_published": "2024-04-16T05:58:19.074Z",
            "content_html": "<blockquote>\n<p>识别出目标主机操作系统的类型和版本，可以大量减少不必要的测试版本，缩小测试范围，更精确地针对目标进行渗透测试<br>\n但是判断目标地操作系统并非一件简单的事情。因为现在的操作系统类型繁多，仅 Windows 和 Linux 就包含了许多衍生系统，同时，现今的防火墙、路由器、智能设备等都有其自带的操作系统，所以需要精确判断目标操作系统的类型并非易事。目前主要通过 &quot;指纹识别&quot; 的方式来对目标的操作系统来进行猜测。检测方法一般分为两种：主动式探测和被动式探测。<br>\n主动式探测：向目标主机发送一段特定的数据包，根据目标主机对数据包做出的回应进行分析，判断目标主机中可能的操作系统类型。和被动探测比起来，主动的方式肯定更为准确，但也同时因为是直接对目标主机进行发送而更容易触发目标安全系统的警报</p>\n</blockquote>\n<p>被动式探测：通过工具嗅探、记录、分析数据包流。根据数据包信息来分析目标主机的操作系统。与主动探测相比，被动探测的结果虽然可能没有那么精确，但是不容易被目标主机的安全系统察觉</p>\n<p>主机识别的原理：Windows 操作系统与 Linux 的操作系统的 TCP/IP 实现方式并不一样，导致对特定格式数据包的回应也不相同，包括响应数据中的内容、响应时间等，就形成了操作系统的指纹。通常的情况下，可以对主机进行 ping 之后根据返回的 TTL 值来判断系统类型</p>\n<p>Windows TTL 起始值：128</p>\n<p>Linux TTL 起始值：64</p>\n<p>每经过一条路由，TTL 值 - 1</p>\n<p>这里就不做界面演示了，可以直接去找 Windows 和 Linux 的机子去 ping 一下看看 TTL 值</p>\n<p>接下来就使用返回 TTL 值的原理来用 python 程序实现自动化探测主机系统类型</p>\n<p>导入程序代码所应用的模块：optparse、os 和 re。optparse 用于生成命令行参数；os 用于执行系统命令；re 为正则表达式模块，用于匹配返回的 TTL 值</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from optparse import OptionParser</span><br><span class=\"line\">import os</span><br><span class=\"line\">import re</span><br></pre></td></tr></table></figure>\n<p>利用 optparse 模块生成命令行参数化形式，对用户输入的参数进行接收和批量处理，最后将处理后的 IP 地址传入 ttl_scan () 函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def main():</span><br><span class=\"line\">    parser = OptionParser(&quot;Usage:%prog -i &lt;target host&gt;&quot;) #输出帮助信息</span><br><span class=\"line\">    parser.add_option(&#x27;-i&#x27;,type=&#x27;string&#x27;,dest=&#x27;IP&#x27;,help=&#x27;specify target host&#x27;)</span><br><span class=\"line\">    #获取IP地址参数</span><br><span class=\"line\">    options,args = parser.parse_args()</span><br><span class=\"line\">    ip = options.IP</span><br><span class=\"line\">    ttl_scan(ip)</span><br><span class=\"line\">    </span><br><span class=\"line\">if __name__ == &quot;__main__&quot;:</span><br><span class=\"line\">    main()</span><br></pre></td></tr></table></figure>\n<p>调用 os.popen () 函数执行 ping 命令，并将返回的结果通过正则表达式识别，提取出 TTL 值。当 TTL 值小于等于 64 时，操作系统为 Linux 类型，输出 &quot;xx.xx.xx.xx<br>\nis Linux/UNIX&quot;，否则输出&quot;xx.xx.xx.xx is Windows&quot;。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def ttl_scan(ip):</span><br><span class=\"line\">    ttlstrmatch = re.compile(r&#x27;ttl=\\d+&#x27;)</span><br><span class=\"line\">    ttlnummatch = re.compile(r&#x27;\\d+&#x27;)</span><br><span class=\"line\">    result = os.popen(&quot;ping -c 1 &quot; + ip)</span><br><span class=\"line\">    res = result.read()</span><br><span class=\"line\">    for line in res.splitlines():</span><br><span class=\"line\">        result = ttlstrmatch.findall(line)</span><br><span class=\"line\">        if result:</span><br><span class=\"line\">            ttl = ttlnummatch.findall(line)</span><br><span class=\"line\">            if int(ttl[0]) &lt;= 64:  # 判断目标主机响应包中TTL值是否小于等于64</span><br><span class=\"line\">                print(&quot;%s is Linux/UNIX&quot; % ip)  # TTL&lt;=64时为Linux/UNIX系统</span><br><span class=\"line\">            else:</span><br><span class=\"line\">                print(&quot;%s is Windows&quot; % ip)  # 反之则为Windows系统</span><br><span class=\"line\">        else:</span><br><span class=\"line\">            pass</span><br></pre></td></tr></table></figure>\n<p>一个简易的检测脚本就完成了，使用方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python3 ./host.py -i IP</span><br></pre></td></tr></table></figure>\n<p>一般来说，主动的主机系统类型探测就是向目标主机发送特定数据包，然后用目标主机的回应包中的数据与指纹库来进行对比，从而得出主机系统类型，这里的脚本化简了这一流程。直接通过 ping 和返回的 TTL 值来对主机系统类型进行一个判断</p>\n",
            "tags": [
                "python"
            ]
        },
        {
            "id": "https://nnnpc.github.io/2024/04/16/%E4%B8%BB%E5%8A%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E2%80%94%E2%80%94%E6%95%8F%E6%84%9F%E7%9B%AE%E5%BD%95%E6%8E%A2%E6%B5%8B/",
            "url": "https://nnnpc.github.io/2024/04/16/%E4%B8%BB%E5%8A%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E2%80%94%E2%80%94%E6%95%8F%E6%84%9F%E7%9B%AE%E5%BD%95%E6%8E%A2%E6%B5%8B/",
            "title": "主动信息收集------敏感目录探测",
            "date_published": "2024-04-16T05:58:19.071Z",
            "content_html": "<blockquote>\n<p>资源发现属于信息收集的一部分，善于发现隐藏信息，如隐藏目录、隐藏文件等，可提高渗透测试的全面细致性。接下来就用 Python 实现敏感目录的发现。在渗透测试过程中，资源发现是极其重要的一环。具备好的资源发现能力能够令整个工作事半功倍。<br>\n在渗透测试过程中进行目录扫描是很有必要的，例如，当发现开发过程中未关闭或者忘记关闭的页面，可能就会发现许多可以利用的信息，接下来编写一个基于字典的目录扫描脚本<br>\n要进行网页的目录扫描，就需要进行网页访问，所以先导入 requests 模块备用，然后等待用户输入 url 和字典</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import requests</span><br><span class=\"line\">headers = &#123;</span><br><span class=\"line\">    &quot;User-Agent&quot;:&quot;Mozilla/5.0 (Windows NT 6.1; WOW64; rv:6.0) Gecko/20100101 Firefox/6.0&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">url = input(&quot;url:&quot;)</span><br><span class=\"line\">txt = input(&#x27;php.txt&#x27;)</span><br></pre></td></tr></table></figure>\n<p>当用户没有输入字典时，默认打开根目录的 php.txt，然后将字典中的内容放进队列中：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">url_list = []</span><br><span class=\"line\">if txt == &quot;&quot;:</span><br><span class=\"line\">    txt = &quot;php.txt&quot;</span><br><span class=\"line\">try:</span><br><span class=\"line\">    with open(txt,&#x27;r&#x27;) as f:</span><br><span class=\"line\">        for a in f:</span><br><span class=\"line\">            a = a.replace(&#x27;\\n&#x27;,&#x27;&#x27;)</span><br><span class=\"line\">            url_list.append(a)</span><br><span class=\"line\">        f.close()</span><br><span class=\"line\">except:</span><br><span class=\"line\">    print(&quot;error!&quot;)</span><br></pre></td></tr></table></figure>\n<p>将队列中的内容拼接到 url 中组成需要验证的地址，通过返回值来判断是否存在此目录</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for li in url_list:</span><br><span class=\"line\">    conn = &quot;http://&quot; + url + &quot;&quot; +li</span><br><span class=\"line\"></span><br><span class=\"line\">    try:</span><br><span class=\"line\">        response = requests.get(conn,headers = headers)</span><br><span class=\"line\">        print(&quot;%s---------------%s&quot; % (conn,response))</span><br><span class=\"line\">    except error.HTTPError as e:</span><br><span class=\"line\">        print(&#x27;%s---------------%s&#x27; %(conn,e.code))</span><br><span class=\"line\">    except error.URLError :</span><br><span class=\"line\">         print(&quot;域名访问失败！&quot;)</span><br><span class=\"line\">         exit(1)</span><br></pre></td></tr></table></figure>\n<p>原理比较简单，可以理解为用字典进行的暴力破解，就是通过需要请求的 url 和字典中的可能存在泄露的目录进行拼接以后挨个访问，用返回的状态码来显示目录是否存在</p>\n",
            "tags": [
                "python"
            ]
        },
        {
            "id": "https://nnnpc.github.io/2024/04/16/%E4%B8%BB%E5%8A%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8ETCP%E3%80%81UDP%E7%9A%84%E4%B8%BB%E6%9C%BA%E5%8F%91%E7%8E%B0/",
            "url": "https://nnnpc.github.io/2024/04/16/%E4%B8%BB%E5%8A%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8ETCP%E3%80%81UDP%E7%9A%84%E4%B8%BB%E6%9C%BA%E5%8F%91%E7%8E%B0/",
            "title": "主动信息收集------基于TCP、UDP的主机发现",
            "date_published": "2024-04-16T05:58:19.070Z",
            "content_html": "<blockquote>\n<p>基于 TCP、UDP 的主机发现属于四层主机发现，是一个位于传输层的协议。可以用来探测远程主机存活、端口开放、服务类型以及系统类型等信息，相比于三层主机发现更为可靠，用途更广<br>\n<strong> TCP</strong> 是一种面向连接的、可靠的传输通信协议，位于 IP 层之上，应用层之下的中间层。它每一次建立连接都需要经过三次握手，终止一次连接也需要四次挥手（四次握手），建立完成之后才能进行传输数据。详解：</p>\n</blockquote>\n<p><a href=\"https://nnnpc.github.io/2022/11/18/%E5%85%B3%E4%BA%8ETCP%E4%B8%8EUDP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%AD%A6%E4%B9%A0/\">https://nnnpc.github.io/2022/11/18 / 关于 TCP 与 UDP 协议的学习 /</a><br>\nTCP 建立的连接可以有效防止丢包和服务器一直在最后的确认状态导致无法关闭的情况发生，因此 TCP 是一个可靠的传输协议</p>\n<p>我们可以利用 TCP 的三次握手来进行主机存活的探测。有两种方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.向目标主机直接发送ACK数据包，如果目标主机存活，就会返回一RST数据包来终止这个不正常的TCP连接</span><br><span class=\"line\">2.发送正常的SYN数据包，如果目标主机返回SYN/ACK或者RST包，也可以证明主机为存活状态</span><br></pre></td></tr></table></figure>\n<p>工作原理主要依据响应数据包中 flags 字段，如果该字段有值则说明主机存活，该字段通常包括 SYN、FIN、ACK、PSH、RST、URG 六种类型。发送 SYN 包表示是建立连接，而发送 FIN 包表示的是关闭连接，ACK 是应答，PSH 表示包含 data 数据传输，RST 表示连接重置，URG 表示紧急指针<br>\n知道了原理和方法之后就可以来编写脚本了，这里还是使用 scapy 库来完成，先进行一个小测试</p>\n<p>首先导入应该用的模块</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from telnetlib import IP</span><br><span class=\"line\">from scapy.all import *</span><br><span class=\"line\">from scapy.layers.inet import TCP</span><br></pre></td></tr></table></figure>\n<p>接着用 a.display () 函数来查看目标主机的返回数据包信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ip = IP()</span><br><span class=\"line\">tcp = TCP()</span><br><span class=\"line\">r = (ip/tcp)</span><br><span class=\"line\">r[IP].dst = &quot;（需要判断的主机IP）&quot;</span><br><span class=\"line\">r[TCP].flags = &quot;A&quot;</span><br><span class=\"line\">a = sr1(r)</span><br><span class=\"line\">a.display()</span><br></pre></td></tr></table></figure>\n<p>结果为：<br>\n<img data-src=\"https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/8xwGKAgwr0dyAmsj.png!thumbnail\" alt=\"\" title=\"fig:\"></p>\n<p>可以明显的看到返回值为返回数据包的标志位为 R，证明主机存活，表示远程主机给源主机发送了一个 REST</p>\n<p>根据以上 TCP 发现主机存活的测试，就可以编写相应的工具来探测主机存活了</p>\n<p>先导入程序代码所应用到的模块：time、optparse、random 和 scapy。time 模块主要用于产生延迟时间，optparse 用于生成命令行参数，random 模块用于生成随机的端口，scapy 用于以 TCP 发送请求以及接受应答数据</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import time</span><br><span class=\"line\">from optparse import OptionParser</span><br><span class=\"line\">from random import randint</span><br><span class=\"line\">from scapy.all import *</span><br></pre></td></tr></table></figure>\n<p>接着利用 optparse 模块生成命令行参数化形式，对用户输入的参数进行接收和批量处理，最后将处理后的 IP 地址传入 Scan () 函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def main():</span><br><span class=\"line\">    usage = &quot;Usage:%prog -i &lt;ip address&gt;&quot;   #输出帮助信息</span><br><span class=\"line\">    parse = OptionParser(usage=usage)</span><br><span class=\"line\">    parse.add_option(&quot;-i&quot;,&#x27;--ip&#x27;,type=&quot;string&quot;,dest=&quot;targetIP&quot;,help=&quot;specify the IP address&quot;)</span><br><span class=\"line\">    options,args = parse.parse_args()</span><br><span class=\"line\">    if &#x27;-&#x27; in options.targetIP:</span><br><span class=\"line\">        for i in range(int(options.tagetIP.split(&#x27;-&#x27;)[0].split(&#x27;-&#x27;)[3]), int(options.targetIP.split(&#x27;-&#x27;)[1]) + 1):</span><br><span class=\"line\">            Scan(</span><br><span class=\"line\">                options.targetIP.split(&#x27;.&#x27;)[0] + &#x27;.&#x27; + options.targetIP.split(&#x27;.&#x27;)[1] + &#x27;.&#x27; + options.targetIP.split(&#x27;.&#x27;)[2] + &#x27;.&#x27; + str(</span><br><span class=\"line\">                    i)</span><br><span class=\"line\">            )</span><br><span class=\"line\">            time.sleep(0.2)</span><br><span class=\"line\">    else:</span><br><span class=\"line\">        Scan(options.targetIP)</span><br><span class=\"line\">      </span><br><span class=\"line\">if __name__ == &#x27;__main__&#x27;:</span><br><span class=\"line\">    main()</span><br></pre></td></tr></table></figure>\n<p>Scan () 函数，通过调用 TCP 将构造好的请求包发送到目的地址，并且根据目标主机返回的数据包中的 flags 字段值判断主机是否存活。若 flags 字段为 R，其整性数值为 4 时表示接收到了目标主机的 REST，目标主机为存活状态</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def Scan():</span><br><span class=\"line\">    try:</span><br><span class=\"line\">        dport = random.randint(1.65535)</span><br><span class=\"line\">        packeet = IP(dst=ip)/TCP(flags=&quot;A&quot;,dport=dport)</span><br><span class=\"line\">        response = sr1(packet,timeout=11.0,verbose=0)</span><br><span class=\"line\">        if response:</span><br><span class=\"line\">            if int(response[TCP].flags) == 4:</span><br><span class=\"line\">                time.sleep(0.5)</span><br><span class=\"line\">                print(ip + &#x27; &#x27;+&quot;is up&quot;)</span><br><span class=\"line\">            else:</span><br><span class=\"line\">                print(ip + &#x27; &#x27;+&quot;is down&quot;)</span><br><span class=\"line\">        else:</span><br><span class=\"line\">            print(ip + &#x27;&#x27; + &quot;is down&quot;)</span><br><span class=\"line\">    except:</span><br><span class=\"line\">        pass</span><br></pre></td></tr></table></figure>\n<p><strong>UDP</strong> 是一种利用 IP 提供提供面向无连接的网络通信服务。UDP 会把应用程序发来的数据，在收到的一刻立即原样发送到网络上。即使在网络传输过程中出现丢包、顺序错乱等情况时，UDP 也不会负责重新发送以及纠错。当向目标发送一个 UDP 数据包之后，目标是不会发回任何 UDP 数据包的。但是如果目标主机处于活跃状态并且目标端口关闭，则会返回一个 ICMP 数据包，这个数据包的含义为 unreachable。如果目标主机不处于活跃状态，这是是收不到任何响应数据的。利用这个原理可以实现探测存活主机</p>\n<p>现在来利用该原理浅浅编写一个程序测试一下，同样利用 scapy 库来完成，首先先导入需要用到的库</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from telnetlib import IP</span><br><span class=\"line\">from scapy.all import *</span><br><span class=\"line\">from scapy.layers.inet import UDP</span><br></pre></td></tr></table></figure>\n<p>接着利用 UDP 协议来判断主机是否存活</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ip = IP()</span><br><span class=\"line\">udp = UDP()</span><br><span class=\"line\">r = (ip/udp)</span><br><span class=\"line\">r[IP].dst = &quot;（需要判断的主机IP）&quot;</span><br><span class=\"line\">r[UDP].dport = 7345</span><br><span class=\"line\">a = sr1(r)</span><br><span class=\"line\">a.display()</span><br></pre></td></tr></table></figure>\n<p>如果目标主机存活，就会接收到目标主机的应答信息。看到返回信息中存在 ICMP 的应答信息，&quot;code=port-unreachable&quot; 表示目标端口不可达，这样就可以验证远程主机存活了，如果不存活则不会收到目标机子的响应数据包<br>\n接下来就可以根据测试结果和原理来编写相应的 python 工具了</p>\n<p>首先需要导入需要用到的模块：time、optparse、random 和 scapy</p>\n<blockquote>\n<p>time：用于产生延迟时间<br>\n optparse：用于生成命令行参数<br>\n random：用于生成随机的端口<br>\n scapy：用于以 UDP 发送请求以及接收应答数据</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import time</span><br><span class=\"line\">from optparse import OptionParser</span><br><span class=\"line\">from random import randint</span><br><span class=\"line\">from scapy.all import *</span><br><span class=\"line\">from telnetlib import IP</span><br><span class=\"line\">from scapy.layers.inet import UDP</span><br></pre></td></tr></table></figure>\n<p>接着利用 optparse 模块生成命令行参数化形式，对用户输入的参数进行批量接收和处理，并将结果传入 Scan () 函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def main():</span><br><span class=\"line\">    usage = &quot;Usage:%prog -i &lt;ip address&gt;&quot;  # 输出帮助信息</span><br><span class=\"line\">    parse = OptionParser(usage=usage)</span><br><span class=\"line\">    parse.add_option(&quot;-i&quot;, &#x27;--ip&#x27;, type=&quot;string&quot;, dest=&quot;targetIP&quot;, help=&quot;specify the IP address&quot;)</span><br><span class=\"line\">    options, args = parse.parse_args()</span><br><span class=\"line\">    if &#x27;-&#x27; in options.targetIP:</span><br><span class=\"line\">        for i in range(int(options.tagetIP.split(&#x27;-&#x27;)[0].split(&#x27;-&#x27;)[3]), int(options.targetIP.split(&#x27;-&#x27;)[1]) + 1):</span><br><span class=\"line\">            Scan(</span><br><span class=\"line\">                options.targetIP.split(&#x27;.&#x27;)[0] + &#x27;.&#x27; + options.targetIP.split(&#x27;.&#x27;)[1] + &#x27;.&#x27; +</span><br><span class=\"line\">                options.targetIP.split(&#x27;.&#x27;)[2] + &#x27;.&#x27; + str(</span><br><span class=\"line\">                    i)</span><br><span class=\"line\">            )</span><br><span class=\"line\">            time.sleep(0.2)</span><br><span class=\"line\">    else:</span><br><span class=\"line\">        Scan(options.targetIP)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">if __name__ == &#x27;__main__&#x27;:</span><br><span class=\"line\">    main()</span><br></pre></td></tr></table></figure>\n<p>main () 函数中的内容与利用 TCP 协议判断存活主机的 main () 中的内容一样，不同之处在 Scan 函数的协议与判断方式<br>\n通过调用 UDP 将构造好的包发送到目标地址，并根据是否接收到目标的响应包来判断目标机子是否存活，当 proto 字段为 1 时则判断为存活状态，否则不存活</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def Scan(ip):</span><br><span class=\"line\">    try:</span><br><span class=\"line\">        dport = random.randint(1,65535)</span><br><span class=\"line\">        packet = IP(dst=ip)/UDP(dport=dport)</span><br><span class=\"line\">        response = sr1(packet,timeout=1.0,verbose=0)</span><br><span class=\"line\">        if response:</span><br><span class=\"line\">            if int(response[IP].proto) == 1:</span><br><span class=\"line\">                time.sleep(0.5)</span><br><span class=\"line\">                print(ip + &#x27; &#x27; + &quot;is up&quot;)</span><br><span class=\"line\">            else:</span><br><span class=\"line\">                print(ip + &#x27; &#x27; + &quot;is down&quot;)</span><br><span class=\"line\">        else:</span><br><span class=\"line\">            print(ip + &#x27; &#x27; + &quot;is down&quot;)</span><br><span class=\"line\">    except:</span><br><span class=\"line\">        pass</span><br></pre></td></tr></table></figure>\n<p>同时也可以使用 nmap 库利用 TCP 和 UDP 协议来进行探测，修改 Scan () 函数中的代码即可（调用函数来使用相应的参数）</p>\n",
            "tags": [
                "python"
            ]
        },
        {
            "id": "https://nnnpc.github.io/2024/04/16/%E4%B8%BB%E5%8A%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8EICMP%E7%9A%84%E4%B8%BB%E6%9C%BA%E5%8F%91%E7%8E%B0/",
            "url": "https://nnnpc.github.io/2024/04/16/%E4%B8%BB%E5%8A%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8EICMP%E7%9A%84%E4%B8%BB%E6%9C%BA%E5%8F%91%E7%8E%B0/",
            "title": "主动信息收集------基于ICMP的主机发现",
            "date_published": "2024-04-16T05:58:19.068Z",
            "content_html": "<blockquote>\n<p>ICMP(Internet Control Message<br>\nProtocol，Internet 报文协议) 是 TCP/IP 的一种子协议，位于 OSI7 层网络模型中的网络层，其目的是用于在 IP 主机、路由器之前传递控制信息<br>\n OS17 层网络模型</p>\n</blockquote>\n<p><img data-src=\"https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/PTXM2FQSmK1RmU69.png!thumbnail\" alt=\"\"></p>\n<blockquote>\n<p>图片来自<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20veXVuamlzdWFuY2hlbmd6aGFuZ2x1L3AvMTY1MDIzMDcuaHRtbA==\"> https://www.cnblogs.com/yunjisuanchengzhanglu/p/16502307.html</span></p>\n</blockquote>\n<p><strong>ICMP 工作流程</strong></p>\n<p>ICMP 中提供了多种报文，这些报文又可以分成两大类：“差错通知 &quot;和&quot; 信息查询”</p>\n<p><strong>差错通知</strong></p>\n<p>当 IP 数据包在对方计算机处理过程中出现未知的发送错误时，ICMP 会向发送者传送错误事实以及错误原因等，示意图如下</p>\n<p><img data-src=\"https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/rANoIf2yrmzE72fY.png!thumbnail\" alt=\"\"></p>\n<p><strong>信息查询</strong></p>\n<p>信息查询由一个请求和一个应答构成的。只需要向目标发送一个请求数据包，如果收到了来自目标的回应，就可以判断目标是活跃主机，否则可以判断目标是非活跃主机，示意图如下</p>\n<p><img data-src=\"https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/NaMzEdM0TcqGBqgt.png!thumbnail\" alt=\"\"></p>\n<p><strong>ICMP 主机探测过程</strong></p>\n<p>Ping 命令是 ICMP 中较为常见的一种应用，经常使用这个命令来测试本地与目标之前的连通性，发送一个 ICMP 请求消息给目标主机，若源主机收到目标主机的应答响应消息，则表示目标可达，主机存在。例如想要判断某一台主机是否为存活主机，那么 ping 一下该主机，查看有无回应即可判断是否存活</p>\n<p>现在来编写一个利用 ICMP 实现探测活跃主机的代码程序。程序有很多种可实现的方法，这里借助 Scapy 库来完成。它是 python 中的一个第三方库，在 Scapy 库中已经实现了大量的网络协议。如 TCP、UDP、IP、ARP 等，使用该库可以灵活编写各种网络工具。</p>\n<p>首先安装 Scapy</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install scapy</span><br></pre></td></tr></table></figure>\n<p>接下来就可以进行实现了<br>\n 1. 导入程序代码所应用到的模块：scapy、random、optparse，其中 scapy 用于发送 ping 请求和接受目标主机的应答数据</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from scapy.all import *</span><br><span class=\"line\">from random import randint</span><br><span class=\"line\">from optparse import OptionParser</span><br></pre></td></tr></table></figure>\n<p>对用户输入的参数进行接受和批量处理，并将处理后的 IP 地址传入 Scan 函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def main():</span><br><span class=\"line\">    parser = OptionParser(&quot;Usage:%prog -i &lt;target host&gt;&quot;)   #输出帮助信息</span><br><span class=\"line\">    parser.add_option(&#x27;-i&#x27;,type=&#x27;string&#x27;,dest=&#x27;IP&#x27;,help=&#x27;specify target host&#x27;)</span><br><span class=\"line\">    #获取IP参数</span><br><span class=\"line\">    options,args = parser.parse_args()</span><br><span class=\"line\">    print(&quot;Scan report for&quot;+options.IP+&quot;\\n&quot;)</span><br><span class=\"line\">    #判断是单台主机还是多台主机</span><br><span class=\"line\">    #IP中存在-，说明是要扫描多台主机</span><br><span class=\"line\">    if &#x27;-&#x27; in options.IP:</span><br><span class=\"line\">    #代码举例：198.168.1.1-120</span><br><span class=\"line\">    #通过”-“进行分隔，把192.168.1.1和120分开</span><br><span class=\"line\">    #把192.168.1.1通过”,“进行分隔，取最后一个属作为range函数的start，然后把120+1作为range函数的stop</span><br><span class=\"line\">    #这样循环遍历出需要扫描的IP地址</span><br><span class=\"line\">        for i in range(int(options.IP.split(&#x27;-&#x27;)[0].split(&#x27;-&#x27;)[3]),int(options.IP.split(&#x27;-&#x27;)[1])+1):</span><br><span class=\"line\">            Scan(</span><br><span class=\"line\">                options.IP.split(&#x27;.&#x27;)[0]+&#x27;.&#x27; +options.IP.split(&#x27;.&#x27;)[1]+&#x27;.&#x27;+options.IP.split(&#x27;.&#x27;)[2]+&#x27;.&#x27;+str(i)</span><br><span class=\"line\">                )</span><br><span class=\"line\">            time.sleep(0.2)</span><br><span class=\"line\">    else:</span><br><span class=\"line\">        Scan(options.IP)</span><br><span class=\"line\">        </span><br><span class=\"line\">    print(&quot;\\nScan finished!...\\n&quot;)</span><br><span class=\"line\">    </span><br><span class=\"line\">if __name__ == &quot;__main__&quot;:</span><br><span class=\"line\">    try:</span><br><span class=\"line\">        main()</span><br><span class=\"line\">    except KeyboardInterrupt:</span><br><span class=\"line\">        print(&quot;interrupted by user,killing all threads...&quot;)</span><br></pre></td></tr></table></figure>\n<p>Scan 函数通过调用 ICMP，将构造好的请求包发送到目的地址，并根据目的地址的应答判断目标主机是否存活。存活的 IP 地址会打印出 &quot;xx.xx.xx.xx-&gt;Host<br>\nis up&quot;，对于不存活的主机打印出&quot;xx.xx.xx.xx-&gt;Host is down&quot;:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def Scan(ip):</span><br><span class=\"line\">    ip_id = randint(1,65535)</span><br><span class=\"line\">    icmp_id = randint(1,65535)</span><br><span class=\"line\">    icmp_seq = randint(1,65535)</span><br><span class=\"line\">    packet=IP(dst=ip,ttl=64,id=ip_id)/ICMP(id=icmp_id,seq=icmp_seq)/b&#x27;rootkit&#x27;</span><br><span class=\"line\">    result = sr1(packet,timeout=1,verbose=False)</span><br><span class=\"line\">    if result:</span><br><span class=\"line\">        for rcv in result:</span><br><span class=\"line\">            scan_ip = rcv[IP].src</span><br><span class=\"line\">            print(scan_ip + &#x27;---&gt;&#x27; &#x27;Host is up&#x27;)</span><br><span class=\"line\">    else:</span><br><span class=\"line\">        print(ip + &#x27;---&gt;&#x27; &#x27;Host is down&#x27;)</span><br></pre></td></tr></table></figure>\n<p><strong>Nmap</strong></p>\n<p>此处，也可以导入 Nmap 库函数，实现探测主机存活工具的编写。这里使用 Nmap 函数的 - sn 与 - PE 参数，-PE 表示使用 ICMP，-sn 表示只测试该主机的状态</p>\n<p>首先导入代码所应用到的模块：nmap、optparse。nmap 模块用于产生 ICMP 的请求数据包，optparse 用于生成命令行参数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import nmap</span><br><span class=\"line\">import optparse</span><br></pre></td></tr></table></figure>\n<p>接着利用 optparse 模块生成命令行参数化形式，对用户输入的参数进行接收和批量处理，最后将处理后的 IP 地址传入 NmapScan 函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if __name__ == &#x27;__main__&#x27;:</span><br><span class=\"line\">    parser = optparse.Optparse(&#x27;usage:python %prog -i ip \\n\\n&#x27;)</span><br><span class=\"line\">    parser.add_option(&#x27;-i&#x27;,&#x27;--ip&#x27;,dest=&#x27;targetIP&#x27;,default=&#x27;192.168.1.1&#x27;,type=&#x27;string&#x27;,help=&#x27;target ip address&#x27;)</span><br><span class=\"line\">    options,args = parser.parse_args()</span><br><span class=\"line\">    if &#x27;-&#x27; in options.targetIP:</span><br><span class=\"line\">        for i in range(int(options.IP.split(&#x27;-&#x27;)[0].split(&#x27;-&#x27;)[3]), int(options.IP.split(&#x27;-&#x27;)[1]) + 1):</span><br><span class=\"line\">            NmapScan(</span><br><span class=\"line\">                options.IP.split(&#x27;.&#x27;)[0] + &#x27;.&#x27; + options.IP.split(&#x27;.&#x27;)[1] + &#x27;.&#x27; + options.IP.split(&#x27;.&#x27;)[2] + &#x27;.&#x27; + str(i)</span><br><span class=\"line\">            )</span><br><span class=\"line\">    else:</span><br><span class=\"line\">        NmapScan(options.IP)</span><br></pre></td></tr></table></figure>\n<p>接下来就是处理 NmapScan 这个扫描判断函数了，因为要传入 - sn<br>\n-PE 参数，所以需要通过调用 nm.scan () 函数来实现，发起 ping 扫描，并打印出扫描之后的结果</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def NmapScan(targetIP):</span><br><span class=\"line\">    #实例化PortScanner对象</span><br><span class=\"line\">    nm = nmap.PortScanner()</span><br><span class=\"line\">    try:</span><br><span class=\"line\">#hosts为目标IP地址，arguments为Nmap的扫描参数</span><br><span class=\"line\">#-sn：使用ping进行扫描</span><br><span class=\"line\">#-PE：使用ICMP的echo请求包（-pp：使用timestamp请求包 -PM：netmask请求包）</span><br><span class=\"line\">        result = nm.scan(host=targetIP,argument=&#x27;-sn -PE&#x27;)</span><br><span class=\"line\">#对结果进行切片，提取主机状态信息</span><br><span class=\"line\">        state = result[&#x27;scan&#x27;][targetIP][&#x27;status&#x27;][&#x27;state&#x27;]</span><br><span class=\"line\">        print(&quot;[&#123;&#125;] is [&#123;&#125;]&quot;.format(targetIP,state))</span><br><span class=\"line\">    except Exception as e:</span><br><span class=\"line\">        pass</span><br></pre></td></tr></table></figure>\n<p>最后，基于 ICMP 协议的主机探测、判断主机存活是一种很常见的方法，无论是以太网还是互联网都能使用。因此，当网络设备，如路由器、防火墙之类的对 ICMP 采取了限制策略，那就会影响到扫描结果，导致结果不准确。<br>\nNmap 模块实现的大体上的流程与使用 Scapy 差不多，相当于是把接受用户参数调用了 optparse 模块来实现，然后同样的遍历传入 NmapScan，再在 NmapScan 函数里面调用一个 nm.scan () 函数来传入 - sn<br>\n-PE 参数，就可以实现 ICMP 协议的实现和主机状态的探测功能</p>\n",
            "tags": [
                "python"
            ]
        },
        {
            "id": "https://nnnpc.github.io/2024/04/16/%E4%B8%BB%E5%8A%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8EARP%E7%9A%84%E4%B8%BB%E6%9C%BA%E5%8F%91%E7%8E%B0/",
            "url": "https://nnnpc.github.io/2024/04/16/%E4%B8%BB%E5%8A%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8EARP%E7%9A%84%E4%B8%BB%E6%9C%BA%E5%8F%91%E7%8E%B0/",
            "title": "主动信息收集------基于ARP的主机发现",
            "date_published": "2024-04-16T05:58:19.066Z",
            "content_html": "<blockquote>\n<p>ARP 协议（地址解析协议）属于数据链路层的协议，主要负责根据网络层地址（IP）来获取数据链路层地址（MAC）<br>\n以太网协议规定，同一局域网中的一台主机要和另一台主机进行直接通信，必须知道目标主机的 MAC 地址。而在 TCP/IP 中，网络层只关注目标主机的 IP 地址。这就导致在以太网中使用 IP 协议时，数据链路层的以太网协议接收到的网络层 IP 协议提供的数据中，只包含目标主机的 IP 地址。于是需要 ARP 协议来完成 IP 地址到 MAC 地址的转换</p>\n</blockquote>\n<p>这里假设一个以太网的结构图，如下图所示</p>\n<p><img data-src=\"https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/W62zPRJlNsUdVncU.png!thumbnail\" alt=\"\"></p>\n<p>在这里假设 PC1 想和 PC3 进行通信，且知道了 PC3 的 IP 地址为 192.168.1.3，但是根据网络层的 IP 无法进行通信，根据以太网的协议规定，两台主机想要进行直接通信必须知道对方的 MAC 地址</p>\n<p>步骤如下：</p>\n<p>1.PC1 会检查自己的 ARP 缓存表中该 IP 是否有对应的 MAC 地址，若有可以直接进行通信</p>\n<p>2. 若无则 PC1 就会使用以太网广播包来给网络上的每一台主机发送 ARP 请求，询问 192.168.1.3 的 MAC 地址，同时 ARP 请求中也包含了 PC1 自己的 IP 地址和 MAC 地址，以太网内的所有主机都会接收到 ARP 请求，并检查是否与自己的 IP 地址相符合。如果不符合则丢弃该 ARP 请求</p>\n<p>3.PC3 确定 ARP 请求中的 IP 与自己的 IP 相符合后，就将 ARP 请求中的 PC1 的 IP 地址与 MAC 地址添加到本地的 ARP 缓存中</p>\n<p>4.PC3 将自己的 MAC 地址发送给 PC1</p>\n<p>5.PC1 收到 PC3 的 ARP 相应，将 PC3 的 IP 地址和 MAC 地址都更新到本地的 ARP 缓存中</p>\n<p>这样就可以进行直接通信了，用一个通俗点的方式来概括说明一下就是：</p>\n<blockquote>\n<p>你（PC1）知道了网友（PC3）的网名或者是 QQ 号（IP 地址），你们打算参加一个网友见面会来面基，在这个活动上你就拿着该网名（IP 地址）去挨个询问（发送 ARP 请求）参加的网友，看看谁是你想要面基的人，不认识的人就否认你的询问，直到问道了网友（PC3），他按照自己的网名知道了自己就是你想寻找的那个人，于是他就把你的网名和名字（MAC 地址）都对应记了下来，并且告诉你了他的名字，你也记下了他的名字，更新了备注<br>\n本地 ARP 缓存表是有生存周期的，生存周期结束后，就会再重复上面的过程</p>\n</blockquote>\n<p>当目标主机与我们共同处于一个以太网时，利用 ARP 进行主机发现是一个最好的选择，这种方式快且精准。同样的我们借助 Scapy 来编写 ARP 主机发现的脚本：</p>\n<blockquote>\n<p>通过脚本对以太网内的每个主机都进行 ARP 请求。若主机存活，则会响应我们的 ARP 请求，否则不会响应。因为 ARP 涉及到网络层和数据链路层，因此需要用到 Scapy 中的 Ether 和 ARP<br>\n 库中的 Eher 和 ARP 参数如下所示</p>\n</blockquote>\n<p><img data-src=\"https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/1IqnAJbXyaBYkwzW.png!thumbnail\" alt=\"\"></p>\n<p>Ether 中的 dst 代表目标 MAC 地址，src 代表源 MAC 地址。ARP 中的 op 代表消息类型，1 为 ARP 请求，2 为 ARP 响应，hwsrc 和 psrc 分别代表源 MAC 地址和源 ip 地址，hwdst 和 pdst 分别代表的是目标 MAC 地址和目标 ip 地址</p>\n<p>导入模块</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import os</span><br><span class=\"line\">import re</span><br><span class=\"line\">import optparse</span><br><span class=\"line\">from scapy.all import *</span><br></pre></td></tr></table></figure>\n<p>编写本机 IP 地址和 MAC 地址获取函数，通过正则表达式来进行获取</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 取IP地址和MAC地址函数</span><br><span class=\"line\">def HostAddress(iface):</span><br><span class=\"line\">    # os.open执行后返回执行结果</span><br><span class=\"line\">    ipData = os.popen(&#x27;ifconfig&#x27; + iface)</span><br><span class=\"line\">    # 对ipData进行类型转换，再用正则进行匹配</span><br><span class=\"line\">    dataLine = ipData.readlines()</span><br><span class=\"line\">    # re.search利用正则匹配返回第一个成功匹配的结果，存在结果则为true</span><br><span class=\"line\">    # 取MAC地址</span><br><span class=\"line\">    if re.search(&#x27;\\w\\w:\\w\\w:\\w\\w:\\w\\w:\\w\\w:\\w\\w&#x27;, str(dataline)):</span><br><span class=\"line\">        # 取出匹配结果</span><br><span class=\"line\">        MAC = re.search(&#x27;\\w\\w:\\w\\w:\\w\\w:\\w\\w:\\w\\w:\\w\\w&#x27;, str(dataLine)).group(0)</span><br><span class=\"line\">    # 取ip地址</span><br><span class=\"line\">    if re.search(r&#x27;((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.)&#123;3&#125;(2[0-4]\\d|25[0-5]|[01]?\\d\\d)&#x27;, str(dataLine)):</span><br><span class=\"line\">        IP = re.search(r&#x27;((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.)&#123;3&#125;(2[0-4]\\d|25[0-5]|[01]?\\d\\d)&#x27;, str(dataLine)).group(0)</span><br><span class=\"line\">    # 将IP和MAC通过元组的形式返回</span><br><span class=\"line\">    addressInfo = (IP, MAC)</span><br><span class=\"line\">    return addressInfo</span><br></pre></td></tr></table></figure>\n<p>接着编写 ARP 探测函数，根据本机的 IP 地址和 MAC 地址信息，自动生成目标进行探测并把结果写入文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#ARP扫描函数</span><br><span class=\"line\">def ArpScan(iface=&#x27;eth0&#x27;):</span><br><span class=\"line\">    #通过HostAddress返回的元组取出MAC地址</span><br><span class=\"line\">    mac = HostAddress(iface)[1]</span><br><span class=\"line\">    #取出本机IP地址</span><br><span class=\"line\">    ip = HostAddress(iface)[0]</span><br><span class=\"line\">    #对本机IP地址进行分隔并作为一句元素，用于生成需要扫描的IP地址</span><br><span class=\"line\">    ipSplit = ip.split(&#x27;.&#x27;)</span><br><span class=\"line\">    #需要扫描的IP地址列表</span><br><span class=\"line\">    ipList = []</span><br><span class=\"line\">    #根据本机IP生成IP扫描范围</span><br><span class=\"line\">    for i in range(1,255):</span><br><span class=\"line\">        ipItem = ipSplit[0] + &#x27;.&#x27; + ipSplit[1] + &#x27;.&#x27; + ipSplit[2] + &#x27;.&#x27; + str(i)</span><br><span class=\"line\">        ipList.append(ipItem)</span><br><span class=\"line\">    &#x27;&#x27;&#x27;</span><br><span class=\"line\">    发送ARP包</span><br><span class=\"line\">    因为要用到OSI的二层和三层，所以要写成Rther/ARP</span><br><span class=\"line\">    因为最底层用到了二层，所以要用srp()发包</span><br><span class=\"line\">    &#x27;&#x27;&#x27;</span><br><span class=\"line\">    result = srp(Ether(src=mac,dst=&#x27;FF:FF:FF:FF:FF:FF&#x27;)/ARP(op=1,hwsrc=mac,hwdst=&#x27;00:00:00:00:00:00&#x27;,pdst=ipList),iface=iface,timeout=2,verbose=False)</span><br><span class=\"line\">    #读取result中的应答包和应答包内容</span><br><span class=\"line\">    resultAns = result[0].res</span><br><span class=\"line\">    #存活主机列表</span><br><span class=\"line\">    liveHost = []</span><br><span class=\"line\">    #number 为接收到应答包的总数</span><br><span class=\"line\">    number = len(resultAns)</span><br><span class=\"line\">    print(&quot;=========================&quot;)</span><br><span class=\"line\">    print(&quot;ARP探测结果&quot;)</span><br><span class=\"line\">    print(&quot;本机ip地址：&quot;+ip)</span><br><span class=\"line\">    print(&quot;本机mac地址：&quot;+mac)</span><br><span class=\"line\">    print(&quot;=========================&quot;)</span><br><span class=\"line\">    for x in range(number):</span><br><span class=\"line\">        IP = resultAns[x][1][1].fields[&#x27;psrc&#x27;]</span><br><span class=\"line\">        MAC = resultAns[x][1][1].fields[&#x27;hwsrc&#x27;]</span><br><span class=\"line\">        liveHost.append([IP,MAC])</span><br><span class=\"line\">        print(&quot;IP:&quot;+IP+&quot;\\n\\n&quot;+&quot;MAC:&quot;+MAC)</span><br><span class=\"line\">        print(&quot;============================&quot;)</span><br><span class=\"line\">    #把存活主机IP写入文件</span><br><span class=\"line\">    resultFile = open(&quot;result&quot;,&quot;w&quot;)</span><br><span class=\"line\">    for i in range(len(liveHost)):</span><br><span class=\"line\">        resultFile.write(liveHost[i][0]+&quot;\\n&quot;)</span><br><span class=\"line\">    resultFile.close()</span><br></pre></td></tr></table></figure>\n<p>编写 main 函数，利用 optparse 模块生成命令行参数化形式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if __name__ == &#x27;__main__&#x27;:</span><br><span class=\"line\">    parser = optparse.OptionParser(&#x27;usage:python %prog -i interfaces \\n\\n&#x27;&#x27;Example:python %prog -i eth0\\n&#x27;)</span><br><span class=\"line\">    #添加网卡参数</span><br><span class=\"line\">    parser.add_option(&#x27;-i&#x27;,&#x27;--iface&#x27;,dest = &#x27;iface&#x27;,default=&#x27;eth0&#x27;,type=&#x27;string&#x27;,help=&#x27;interfaces name&#x27;)</span><br><span class=\"line\">    (options,args) = parser.parse_args()</span><br><span class=\"line\">    ArpScan(options.iface)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>提示：普通用户运行时需要 sudo，不然会出现 Operation not permitted 的提醒</p>\n</blockquote>\n",
            "tags": [
                "python"
            ]
        },
        {
            "id": "https://nnnpc.github.io/2024/04/16/%E4%B8%BB%E5%8A%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E2%80%94%E2%80%94%E6%9C%8D%E5%8A%A1%E8%AF%86%E5%88%AB/",
            "url": "https://nnnpc.github.io/2024/04/16/%E4%B8%BB%E5%8A%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E2%80%94%E2%80%94%E6%9C%8D%E5%8A%A1%E8%AF%86%E5%88%AB/",
            "title": "主动信息收集------服务识别",
            "date_published": "2024-04-16T05:58:19.064Z",
            "content_html": "<blockquote>\n<p>在渗透测试的过程中，服务识别是一个很重要的环节，如果能识别出目标主机的服务、版本等信息，对于渗透测试将有重要帮助。对于入侵者来说，发现这些运行在目标上的服务，就可以利用这些软件上的漏洞入侵目标；对于网络安全的维护者来说，也可以提前发现系统的漏洞，从而预防这些入侵行为<br>\n很多的扫描工具都是采用了一种十分简单的方式，就是根据端口号来判断服务的类型，因为通常很多常见的服务都会运行在固定的端口上，如下表</p>\n</blockquote>\n<p>端口号     说明                   作用</p>\n<hr>\n<p>21/22/69   FTP/TFTP               允许匿名上传、下载、破解和嗅探攻击<br>\n 2049       NFS 服务                配置不当<br>\n 139        Samba 服务              破解、未授权访问、远程代码执行<br>\n 389        LDAP（目录访问协议）   注入、允许匿名访问、使用弱口令</p>\n<p>文件共享服务端口</p>\n<p>端口号   说明              作用</p>\n<hr>\n<p>22       SSH 远程连接       破解、SSH 隧道以及内网代理转发，文件传输<br>\n 23       Telnet 远程连接    破解、嗅探、弱口令<br>\n 3389     Rdp 远程桌面连接   Shift 后门（需要 Windows Server 2003 以下的系统）、破解<br>\n 5900     VNC               弱口令破解<br>\n 5632     PyAnywhere        抓密码、代码执行</p>\n<p>远程连接服务端口</p>\n<p>端口号        说明                        作用</p>\n<hr>\n<p>80/443/8080   常见 Web 服务端口             Web 攻击、破解、服务器版本漏洞<br>\n 7001/7002     WebLogic 控制台              Java 反序列化、弱口令<br>\n 8080/8089     Jboss/Resin/Jetty/JenKins   反序列化、控制台弱口令<br>\n 9090          WebSphere 控制台             Java 反序列化、弱口令<br>\n 4848          GlassFish 控制台             弱口令<br>\n 1352          Lotus Domino 邮件服务        弱口令、信息泄露、破解<br>\n 10000         Webmin-Web 控制面板          弱口令</p>\n<p>Web 应用服务端口</p>\n<p>端口号        说明               作用</p>\n<hr>\n<p>3306          MySOL              注入、提权、破解<br>\n 1433          MSSQL              注入、提权、SA 弱口令、破解<br>\n 1521          Oracle 数据库       TNS 破解、注入、反弹 shell<br>\n5432          PostgreSQL 数据库   破解、注入、弱口令<br>\n 27017/27018   MongoDB            破解、未授权访问<br>\n 6379          Redis 数据库        可尝试未授权访问、弱口令破解<br>\n 5000          SysBase/DB2        破解、注入</p>\n<p>数据库服务端口</p>\n<p>端口号   说明           作用</p>\n<hr>\n<p>25       SMTP 邮件服务   邮件伪造<br>\n 110      POP3 协议       破解、嗅探<br>\n 143      IMAP 协议       破解、收集目标内网信息</p>\n<p>邮件服务端口</p>\n<p>端口号   说明          作用</p>\n<hr>\n<p>53       DNS 域名系统   允许区域传送、DNS 劫持、缓存投毒、欺骗<br>\n 67/68    DHCP 服务      劫持、欺骗<br>\n 161      SNMP 协议      破解、搜集目标内网信息</p>\n<p>网络常见协议端口</p>\n<p>端口号        说明                     作用</p>\n<hr>\n<p>2181          Zookeeper 服务            未授权访问<br>\n 8096          Zabbix 服务               远程执行、SQL 注入<br>\n 9200/9300     Elasticsearch            远程执行<br>\n 11211         Memcache                 未授权访问<br>\n 512/513/514   Linux Rexec 服务          破解、Rlogin 登录<br>\n 873           Rsync 服务                匿名访问、文件上传<br>\n 3690          SVN 服务                  SVN 泄露、未授权访问<br>\n 50000         SAP Management Console   远程执行</p>\n<p>特殊服务端口</p>\n<p>而对端口的服务进行探测的方法就是向目标开放的端口发送探针数据包，根据目标主机返回的 banner 信息与已经存储总结的 banner 信息进行对比，进而确认服务类型。而强大的 Nmap 也是利用了这种方法，它有一个十分强大的 banner 库，这个库也还在不断的完善当中</p>\n<p>根据这个特性与方法，就可以来编写扫描端口服务类型的程序了</p>\n<p>先导入所需要用到的模块，time 用于模块主要用于产生延迟时间，optparse 模块用于生成命令行参数，socket 模块用于产生 TCP 请求，re 模块为正则表达式模块，与指纹信息进行有效匹配，进而确定服务类型。SIGNS 为指纹库用于对目标主机返回的 banner 信息进行匹配，读者可自行添加扩展</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from optparse import OptionParser</span><br><span class=\"line\">import time</span><br><span class=\"line\">import socket</span><br><span class=\"line\">import re</span><br><span class=\"line\"></span><br><span class=\"line\">SIGNS = (</span><br><span class=\"line\">    #协议|版本|关键字</span><br><span class=\"line\">    b&#x27;FTP|FTP|^220.*FTP&#x27;,</span><br><span class=\"line\">    b&#x27;MySQL|MySQL|mysql_native_password&#x27;,</span><br><span class=\"line\">    b&#x27;oracle-https|^220- ora&#x27;,</span><br><span class=\"line\">    b&#x27;Telnet|Telnet|Telnet&#x27;,</span><br><span class=\"line\">    b&#x27;Telnet|Telnet|^\\r\\n%connection closed by remote host!\\x00$&#x27;,</span><br><span class=\"line\">    b&#x27;VNC|VNC|^RFB&#x27;,</span><br><span class=\"line\">    b&#x27;IMAP|IMAP|^\\* OK.*?IMAP&#x27;,</span><br><span class=\"line\">    b&#x27;POP|POP|^\\+OK.*?&#x27;,</span><br><span class=\"line\">    b&#x27;SMTP|SMTP|^220.*?SMTP&#x27;,</span><br><span class=\"line\">    b&#x27;Kangle|Kangle|HTTP.*kangle&#x27;,</span><br><span class=\"line\">    b&#x27;SMTP|SMTP|^554 SMTP&#x27;,</span><br><span class=\"line\">    b&#x27;SSH|SSH|^SSH-&#x27;,</span><br><span class=\"line\">    b&#x27;HTTPS|HTTPS|Location:https&#x27;,</span><br><span class=\"line\">    b&#x27;HTTP|HTTP|HTTP/1.1&#x27;,</span><br><span class=\"line\">    b&#x27;HTTP|HTTP|HTTP/1.0&#x27;,</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>接着利用 optparse 模块生成命令行参数化形式，对用户输入的参数进行接收和批量的处理，最后将处理后的 IP 地址及端口 port 传入 request () 函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def main():</span><br><span class=\"line\">    parser = OptionParser(&quot;Usage:%prog -i &lt;target host&gt;&quot;)#输出帮助信息</span><br><span class=\"line\">    parser.add_option(&#x27;-i&#x27;,type=&#x27;string&#x27;,dest=&#x27;IP&#x27;,help=&#x27;specify target host&#x27;)</span><br><span class=\"line\">    #获取IP地址参数</span><br><span class=\"line\">    parser.add_option(&#x27;-p&#x27;,type=&#x27;string&#x27;,dest=&#x27;PORT&#x27;,help=&#x27;specify target host&#x27;)</span><br><span class=\"line\">    #获取端口参数</span><br><span class=\"line\">    options,args = parser.parse_args()</span><br><span class=\"line\">    ip = options.IP</span><br><span class=\"line\">    port = options.PORT</span><br><span class=\"line\">    print(&quot;Scan report for &quot;+ip+&quot;\\n&quot;)</span><br><span class=\"line\">    for line in port.split(&#x27;,&#x27;):</span><br><span class=\"line\">        request(ip,line)</span><br><span class=\"line\">        time.sleep(0.2)</span><br><span class=\"line\">    print(&quot;\\nScan finished!...\\n&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">if __name__ == &quot;__main__&quot;:</span><br><span class=\"line\">    try:</span><br><span class=\"line\">        main()</span><br><span class=\"line\">    except KeyboardInterrupt:</span><br><span class=\"line\">        print(&quot;interrupted by user,killing all threads...&quot;)</span><br></pre></td></tr></table></figure>\n<p>在 request () 函数中，首先调用 sock.connect () 函数探测目标主机的端口是否开放，如果端口开放，则利用 sock.sendall () 函数将 PROBE 探针发送给目标端口。sock.recv () 函数用于接收返回的指纹信息，并将指纹信息及端口发送到 regex () 函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def request(ip,port):</span><br><span class=\"line\">    response = &#x27;&#x27;</span><br><span class=\"line\">    PROBE = &#x27;GET / HTTP/1.0\\r\\n\\r\\n&#x27;</span><br><span class=\"line\">    sock = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class=\"line\">    sock.settimeout(10)</span><br><span class=\"line\">    result = sock.connect_ex((ip,int(port)))</span><br><span class=\"line\">    if result == 0:</span><br><span class=\"line\">        try:</span><br><span class=\"line\">            sock.sendall(PROBE.encode())</span><br><span class=\"line\">            response = sock.recv(256)</span><br><span class=\"line\">            if response:</span><br><span class=\"line\">                regex(response,port)</span><br><span class=\"line\">        except(ConnectionResetError,socket.timeout):</span><br><span class=\"line\">           pass</span><br><span class=\"line\">    else:</span><br><span class=\"line\">        pass</span><br></pre></td></tr></table></figure>\n<p>利用 re.search () 函数将返回的 banner 信息与 SIGNS 包含的指纹信息进行正则匹配，并将匹配到的结果输出。如果没有在 SIGNS 中找到想匹配的信息，则输出 Unrecognized</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def regex(response,port):</span><br><span class=\"line\">    text = &quot;&quot;</span><br><span class=\"line\">    if re.search(b&#x27;&lt;title&gt;502 Bad Geteway&#x27;,response):</span><br><span class=\"line\">        proto = &#123;&quot;Service failed to access!!&quot;&#125;</span><br><span class=\"line\">    for pattern in SIGNS:</span><br><span class=\"line\">        pattern = pattern.split(b&#x27;|&#x27;)</span><br><span class=\"line\">        if re.search(pattern[-1],response,re.IGNORECASE):</span><br><span class=\"line\">            proto = &quot;[&quot;+port+&quot;]&quot;+&quot;open&quot;+pattern[1].decode()</span><br><span class=\"line\">            break</span><br><span class=\"line\">        else:</span><br><span class=\"line\">            proto = &quot;[&quot;+port+&quot;]&quot;+&quot;open&quot;+&quot;Unrecognized&quot;</span><br><span class=\"line\">        print(proto)</span><br></pre></td></tr></table></figure>\n<p>市面上的软件种类繁多，版本也不一样，因此端口服务版本要想实现比较困难，</p>\n",
            "tags": [
                "python"
            ]
        },
        {
            "id": "https://nnnpc.github.io/2024/04/16/%E4%B8%BB%E5%8A%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E2%80%94%E2%80%94%E7%AB%AF%E5%8F%A3%E6%8E%A2%E6%B5%8B/",
            "url": "https://nnnpc.github.io/2024/04/16/%E4%B8%BB%E5%8A%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E2%80%94%E2%80%94%E7%AB%AF%E5%8F%A3%E6%8E%A2%E6%B5%8B/",
            "title": "主动信息收集------端口探测",
            "date_published": "2024-04-16T05:58:19.062Z",
            "content_html": "<blockquote>\n<p>端口是设备与外界通信交流的接口，如果把服务器看作一栋房子，那么端口就是可以进出这栋房子的门。真正的房子只有一个或者几个门，但是服务器至多可以有 65536 个门。不同的端口指向不同的服务，就像不同的门对应不同的房间<br>\n最常见的三个服务端口就是 80、21、3389，分别对应的是浏览网页时涉及的 www 服务，上传和下载文件的服务，远程桌面的服务。如果入侵者想要控制这个服务器，那么肯定得先通过一个端口进入该服务，就如同控制房子首先得通过门进入房间一样，因此，在信息的收集阶段，端口的扫描就尤为重要</p>\n</blockquote>\n<p>这里使用 python 的 socket 模块来进行端口扫描的编写，先导入需要用到的模块</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import sys</span><br><span class=\"line\">import socket</span><br><span class=\"line\">import optparse</span><br><span class=\"line\">import threading</span><br><span class=\"line\">import queque</span><br></pre></td></tr></table></figure>\n<p>接着编写一个端口扫描类，继承 threading.Thread。这个类需要传递 3 个参数，分别是目标 IP、端口队列、超时时间，通过这个类来创造多个子线程来加快扫描速度</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 端口扫描类,继承threading.Thread</span><br><span class=\"line\">class PortScaner(threading.Thread):</span><br><span class=\"line\">    def __init__(self, portqueue, ip, timeout=3):</span><br><span class=\"line\">        threading.Thread.__init__(self)</span><br><span class=\"line\">        self._potqueue = portqueue</span><br><span class=\"line\">        self._ip = ip</span><br><span class=\"line\">        self._timeout = timeout</span><br><span class=\"line\"></span><br><span class=\"line\">    def run(self):</span><br><span class=\"line\">        while True:</span><br><span class=\"line\">            # 判断端口队列是否为空</span><br><span class=\"line\">            if self._portqueue.empty():</span><br><span class=\"line\">                # 端口队列为空，说明已经扫描完毕，跳出循环</span><br><span class=\"line\">                break</span><br><span class=\"line\">            # 从端口队列中取出端口，超时时间为1s</span><br><span class=\"line\">            port = self._portqueue.get(timeout=0.5)</span><br><span class=\"line\">            try:</span><br><span class=\"line\">                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class=\"line\">                s.settimeout(self._timeout)</span><br><span class=\"line\">                result_code = s.connect_ex((self._ip, port))</span><br><span class=\"line\">                # sys.stdout.write(&quot;[%d]Scan\\n&quot;%port)</span><br><span class=\"line\">                # 若端口开放，则会返回0</span><br><span class=\"line\">                if result_code == 0:</span><br><span class=\"line\">                    sys.stdout.write(&quot;[%d] OPEN\\n&quot; % port)</span><br><span class=\"line\">            except Exception as e:</span><br><span class=\"line\">                print(e)</span><br><span class=\"line\">            finally:</span><br><span class=\"line\">                s.close()</span><br></pre></td></tr></table></figure>\n<p>编写一个函数，根据用户的参数来指定目标 IP、端口队列的生成以及子线程的生成，同时能支持单个端口的扫描和范围端口的扫描</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def StartScan(targetip, port, threadNum):</span><br><span class=\"line\">    # 端口列表</span><br><span class=\"line\">    portList = []</span><br><span class=\"line\">    portNumb = port</span><br><span class=\"line\">    # 判断是单个端口还是范围端口</span><br><span class=\"line\">    if &#x27;-&#x27; in port:</span><br><span class=\"line\">        for i in range(int(port.split(&#x27;-&#x27;)[0]), int(port.split(&#x27;-&#x27;)[1]) + 1):</span><br><span class=\"line\">            portList.append(i)</span><br><span class=\"line\">    else:</span><br><span class=\"line\">        portList.append(int(port))</span><br><span class=\"line\">    # 目标IP地址</span><br><span class=\"line\">    ip = targetip</span><br><span class=\"line\">    # 线程列表</span><br><span class=\"line\">    threads = []</span><br><span class=\"line\">    # 线程数量</span><br><span class=\"line\">    threadNumber = threadNum</span><br><span class=\"line\">    # 端口队列</span><br><span class=\"line\">    portQueue = queue.Queue()</span><br><span class=\"line\">    # 生成端口，加入端口队列</span><br><span class=\"line\">    for port in portList:</span><br><span class=\"line\">        portQueue.put(port)</span><br><span class=\"line\">    for t in range(threadNumber):</span><br><span class=\"line\">        threads.append(PortScaner(portQueue, ip, timeout=3))</span><br><span class=\"line\">    # 启动线程</span><br><span class=\"line\">    for thread in threads:</span><br><span class=\"line\">        thread.start()</span><br><span class=\"line\">    # 阻塞线程</span><br><span class=\"line\">    for thread in threads:</span><br><span class=\"line\">        thread.join()</span><br></pre></td></tr></table></figure>\n<p>编写主函数来指定参数的规则</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if __name__ == &#x27;__main__&#x27;:</span><br><span class=\"line\">    parser = optparse.OptionParser(&#x27;Example:python %prog -i 127.0.0.1 -p 80 \\n python %prog -i 127.0.0.1 -p 1-100\\n&#x27;)</span><br><span class=\"line\">    # 目标IP参数-i</span><br><span class=\"line\">    parser.add_option(&#x27;-i&#x27;, &#x27;--ip&#x27;, dest=&#x27;targetIP&#x27;, default=&#x27;127.0.0.1&#x27;, type=&#x27;string&#x27;, help=&#x27;target IP&#x27;)</span><br><span class=\"line\">    # 添加端口参数-p</span><br><span class=\"line\">    parser.add_option(&#x27;-p&#x27;, &#x27;--port&#x27;, dest=&#x27;port&#x27;, default=&#x27;80&#x27;, type=&#x27;string&#x27;, help=&#x27;scann port&#x27;)</span><br><span class=\"line\">    # 线程数量参数-t</span><br><span class=\"line\">    parser.add_option(&#x27;-t&#x27;, &#x27;--thread&#x27;, dest=&#x27;threadNum&#x27;, default=100, type=&#x27;int&#x27;, help=&#x27;scann thread number&#x27;)</span><br><span class=\"line\">    (options, args) = parser.parse_args()</span><br><span class=\"line\">StartScan(options.targetIP, options.port, options.threadNum)</span><br></pre></td></tr></table></figure>\n<p>接下来用自己的服务器测试一下开放端口</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python3 ./ce.py -i ip -p 端口</span><br></pre></td></tr></table></figure>\n<p><img data-src=\"https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/7vUkGrUiTBOK48Ag.png!thumbnail\" alt=\"\"></p>\n<p>这是测试单个端口的开放，也同时可以设置多线程跑范围端口</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python3 ./ce.py -i ip -p 1-3500 -t 100</span><br></pre></td></tr></table></figure>\n<p><img data-src=\"https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/62ddNYx8s5Zy4KAq.png!thumbnail\" alt=\"\"></p>\n<p>同时也可以使用 nmap 库来修改工具进行端口扫描，所需修改的部分代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">result = nm.scan(hosts=targetIP,arguments=&#x27;-p&#x27;+str(targetPort))</span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "python"
            ]
        },
        {
            "id": "https://nnnpc.github.io/2024/04/16/%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E8%BD%AC%E6%8D%A2/",
            "url": "https://nnnpc.github.io/2024/04/16/%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E8%BD%AC%E6%8D%A2/",
            "title": "可执行文件的转换",
            "date_published": "2024-04-16T05:58:19.050Z",
            "content_html": "<blockquote>\n<p>当开发者向普通用户分享程序时，为了方便用户在未安装 Python 环境的情况下能够正常运行，需要将开发好的程序进行打包，转换成用户可运行的文件类型。<br>\nPyInstaller 是常见的执行文件打包工具。该工具的安装方式十分简单，可运行在 Windows、MacOS<br>\nX 和 GUN/Linux 操作系统环境中，支持 Python2 和 Python3 两种版本，并且在不同的操作系统环境中，PyInstaller 工具的使用方法和选项相同。<br>\n需要注意的是，用 PyInstaller 打包的执行文件，只能在与执行打包操作的系统类型相同的环境下运行。也就是说这样的执行文件不具备可移植性，比如在 Windows 系统下用 PyInstaller 生成的执行文件只能运行在 Windows 环境，在 Linux 系统下生成的执行文件只能运行在 Linux 环境。<br>\n总的来说：虽然在不同的操作系统下 PyInstaller 工具的使用方法和选项相同，但是在哪一个操作系统下执行打包操作，该生成的执行文件就只能在该系统环境下运行</p>\n</blockquote>\n<p><strong>1. 在 Windows 系统下转换</strong></p>\n<p>首先从官方网站（<span class=\"exturl\" data-url=\"aHR0cHM6Ly9weXBpLm9yZy9wcm9qZWN0L3B5aW5zdGFsbGVyLw==\">https://pypi.org/project/pyinstaller</span>）下载 PyInstaller 的安装包，将下载好的 PyInstaller 压缩包文件进行解压</p>\n<p><img data-src=\"https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/oSQ0R0uZ8SqxgcUr.png!thumbnail\" alt=\"\"></p>\n<p>解压好的文件夹下包含 setup.py 文件。可通过执行如下命令对 PyInstaller 进行安装</p>\n<p><img data-src=\"https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/8vBFPWjTx3Jk4BM7.png!thumbnail\" alt=\"\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python3 setup.py install</span><br></pre></td></tr></table></figure>\n<p>但是可能会出现一些报错，可以尝试以下 pip install<br>\npyinstaller，当然如果还是报错的话可以下载 whl 文件，如图</p>\n<p><img data-src=\"https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/chJfo7BxMzzpbZNT.png!thumbnail\" alt=\"\"></p>\n<p>再用命令进行安装</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip3 install pyinstaller-5.7.0-py3-none-win_amd64.whl</span><br></pre></td></tr></table></figure>\n<p>安装完成之后就是进行打包了，准备好需要打包的文件和需要绑定的图标，图标需为.ico 后缀。将两个文件放入同一个文件夹中，再在该路径下开启 cmd 运行命令进行打包</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pyinstaller -F -i cat.ico encode.py</span><br></pre></td></tr></table></figure>\n<p>执行效果：<br>\n<img data-src=\"https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/iGVf6dyGN2TARGE3.png!thumbnail\" alt=\"\" title=\"fig:\"></p>\n<p>执行之后的文件可以在 dist 文件夹中找到</p>\n<p><strong>2. 在 Linux 系统下的转换</strong></p>\n<p>这里使用 Ubuntu 进行演示，使用命令进行安装</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install pyinstaller</span><br></pre></td></tr></table></figure>\n<p>安装完成后执行打包操作（同样需要找到一个指定目录，这里就直接在桌面上执行打包，生成的目录也自然就在桌面上了）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pyinstaller -F encode.py</span><br></pre></td></tr></table></figure>\n<p>执行效果：<br>\n<img data-src=\"https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/ZIcJGnoZbtMpuZ0O.png!thumbnail\" alt=\"\" title=\"fig:\"></p>\n<p>成功之后同样可以在 dist 目录中找到</p>\n<p><img data-src=\"https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/lmJYorSCSkYKOHKJ.png!thumbnail\" alt=\"\"></p>\n<p>pyinstaller 安装方法挺多的，如果遇到一些比较难解决的报错可以尝试换一种方法进行下载，本人 windows 下载就是用 whl 文件，linux 是直接 pip 就可以了</p>\n",
            "tags": [
                "python"
            ]
        },
        {
            "id": "https://nnnpc.github.io/2024/04/16/%E8%A2%AB%E5%8A%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/",
            "url": "https://nnnpc.github.io/2024/04/16/%E8%A2%AB%E5%8A%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/",
            "title": "被动信息收集",
            "date_published": "2024-04-16T05:58:19.043Z",
            "content_html": "<p>信息收集通常可以分为<strong>被动信息收集</strong>和 ** 主动信息收集，** 被动信息收集是指不与目标主机进行直接交互，通常根据搜索引擎或者社交等方式间接获取目标主机的信息；主动信息收集是指与目标主机进行直接交互，从而获取所需要的目标信息</p>\n<p>攻击者比较关注目标主机的所有信息，比如：子域名、IP 地址、旁站、C 段查询、用户邮箱 CMS 类型、敏感目录、端口信息、服务器版本以及中间件等</p>\n<p>被动信息收集主要是通过一些收集引擎例如 fofa、鹰图等等进行收集、或者通过一些社交方式来获得一些信息。该方法是不与目标机子产生交互的，可以不接触目标的情况下挖掘目标信息。主要方法包括：DNS 解析、子域名挖掘、邮件爬取等等</p>\n<p><strong>DNS 解析</strong></p>\n<p>DNS 是一种分布式网络目录服务，主要用于域名与 ip 地址的相互转换，能够使用户更方便地访问互联网，TCP/IP 中的 IP 地址是由四段以 &quot;.&quot; 分开地数字组成，记起来总是不如名字那么方便，所以采用了域名系统来管理名字和 IP 地对应关系</p>\n<p><strong>IP 查询</strong></p>\n<p>IP 查询是通过当前所获取到的 URL 去查询对应 IP 地址的过程。可以应用 Socket 库函数中的 gethostbyname () 获取域名所对应的 IP 值</p>\n<p>例：查询域名<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmFpZHUueG4tLWNvbS1scTBmMzhpZDlneG01Yg==\"> www.baidu.com</span> 所对应的 IP 值</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import socket</span><br><span class=\"line\">ip = socket.gethostbyname(&#x27;www.baidu.com&#x27;)</span><br><span class=\"line\">print(ip)</span><br></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">112.80.248.75</span><br></pre></td></tr></table></figure>\n<p><strong>Whois 查询</strong></p>\n<p>Whois 是用来查询域名的 IP 以及所有者信息的传输协议。简单地说，Whois 就是一个数据库，用来查询域名是否已经被注册，以及注册域名的详细信息（如域 - 名所有人、域名注册商等）。Python 中的 python-whois 模块可以用于 Whois 的查询</p>\n<p>先通过 pip 安装 python-whois 模块：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install python-whois·</span><br></pre></td></tr></table></figure>\n<p>通过自带的 whois 模块查询域名<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmFpZHUuY29t\"> www.baidu.com</span><br>\n 的注册信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from whois import whois</span><br><span class=\"line\">data = whois(&#x27;www.baidu.com&#x27;)</span><br><span class=\"line\">print(data)</span><br></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;domain_name&quot;: [</span><br><span class=\"line\">    &quot;BAIDU.COM&quot;,</span><br><span class=\"line\">    &quot;baidu.com&quot;</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  &quot;registrar&quot;: &quot;MarkMonitor, Inc.&quot;,</span><br><span class=\"line\">  &quot;whois_server&quot;: &quot;whois.markmonitor.com&quot;,</span><br><span class=\"line\">  &quot;referral_url&quot;: null,</span><br><span class=\"line\">  &quot;updated_date&quot;: [</span><br><span class=\"line\">    &quot;2022-09-01 03:54:43&quot;,</span><br><span class=\"line\">    &quot;2022-09-01 03:29:31&quot;</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  &quot;creation_date&quot;: &quot;1999-10-11 11:05:17&quot;,</span><br><span class=\"line\">  &quot;expiration_date&quot;: [</span><br><span class=\"line\">    &quot;2026-10-11 11:05:17&quot;,</span><br><span class=\"line\">    &quot;2026-10-11 07:00:00&quot;</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  &quot;name_servers&quot;: [</span><br><span class=\"line\">    &quot;NS1.BAIDU.COM&quot;,</span><br><span class=\"line\">    &quot;NS2.BAIDU.COM&quot;,</span><br><span class=\"line\">    &quot;NS3.BAIDU.COM&quot;,</span><br><span class=\"line\">    &quot;NS4.BAIDU.COM&quot;,</span><br><span class=\"line\">    &quot;NS7.BAIDU.COM&quot;,</span><br><span class=\"line\">    &quot;ns7.baidu.com&quot;,</span><br><span class=\"line\">    &quot;ns4.baidu.com&quot;,</span><br><span class=\"line\">    &quot;ns1.baidu.com&quot;,</span><br><span class=\"line\">    &quot;ns2.baidu.com&quot;,</span><br><span class=\"line\">    &quot;ns3.baidu.com&quot;</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  &quot;status&quot;: [</span><br><span class=\"line\">    &quot;clientDeleteProhibited https://icann.org/epp#clientDeleteProhibited&quot;,</span><br><span class=\"line\">    &quot;clientTransferProhibited https://icann.org/epp#clientTransferProhibited&quot;,</span><br><span class=\"line\">    &quot;clientUpdateProhibited https://icann.org/epp#clientUpdateProhibited&quot;,</span><br><span class=\"line\">    &quot;serverDeleteProhibited https://icann.org/epp#serverDeleteProhibited&quot;,</span><br><span class=\"line\">    &quot;serverTransferProhibited https://icann.org/epp#serverTransferProhibited&quot;,</span><br><span class=\"line\">    &quot;serverUpdateProhibited https://icann.org/epp#serverUpdateProhibited&quot;,</span><br><span class=\"line\">    &quot;clientUpdateProhibited (https://www.icann.org/epp#clientUpdateProhibited)&quot;,</span><br><span class=\"line\">    &quot;clientTransferProhibited (https://www.icann.org/epp#clientTransferProhibited)&quot;,</span><br><span class=\"line\">    &quot;clientDeleteProhibited (https://www.icann.org/epp#clientDeleteProhibited)&quot;,</span><br><span class=\"line\">    &quot;serverUpdateProhibited (https://www.icann.org/epp#serverUpdateProhibited)&quot;,</span><br><span class=\"line\">    &quot;serverTransferProhibited (https://www.icann.org/epp#serverTransferProhibited)&quot;,</span><br><span class=\"line\">    &quot;serverDeleteProhibited (https://www.icann.org/epp#serverDeleteProhibited)&quot;</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  &quot;emails&quot;: [</span><br><span class=\"line\">    &quot;abusecomplaints@markmonitor.com&quot;,</span><br><span class=\"line\">    &quot;whoisrequest@markmonitor.com&quot;</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  &quot;dnssec&quot;: &quot;unsigned&quot;,</span><br><span class=\"line\">  &quot;name&quot;: null,</span><br><span class=\"line\">  &quot;org&quot;: &quot;Beijing Baidu Netcom Science Technology Co., Ltd.&quot;,</span><br><span class=\"line\">  &quot;address&quot;: null,</span><br><span class=\"line\">  &quot;city&quot;: null,</span><br><span class=\"line\">  &quot;state&quot;: &quot;Beijing&quot;,</span><br><span class=\"line\">  &quot;registrant_postal_code&quot;: null,</span><br><span class=\"line\">  &quot;country&quot;: &quot;CN&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>子域名挖掘</strong></p>\n<p>域名可以分为顶级域名、一级域名、二级域名。子域名是顶级域名（一级域名或父域名）的下一级，例如 mail.example.com 和 calendar.example.com 是 example.com 的两个子域而 example.com 则是顶级域.com 的子域。在测试过程中，测试目标主站时如果未发现任何相关漏洞，此时通常会考虑挖掘目标系统的子域名。子域名的挖掘方式有很多种，例如：搜索引擎、子域名破解、字典查询等等</p>\n<p>这里用 python 写一个子域名的挖掘工具（通过 Bing 搜索引擎进行子域名搜集）：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#! /usr/bin/env python</span><br><span class=\"line\"># _*_ coding:utf-8_*_</span><br><span class=\"line\">import requests</span><br><span class=\"line\">from bs4 import BeautifulSoup</span><br><span class=\"line\">from urllib.parse import urlparse</span><br><span class=\"line\">import sys</span><br><span class=\"line\"></span><br><span class=\"line\">def bing_search(site,pages):</span><br><span class=\"line\">    Sudbomain = []</span><br><span class=\"line\">    headers = &#123;</span><br><span class=\"line\">        &#x27;User-Agent&#x27;:&#x27;Mozilla/5.0 (X11; Linux x86_64; rv:68.0)Gecko/20100101 Firefox/68.0&#x27;</span><br><span class=\"line\">        &#x27;Accept&#x27;:&#x27;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&#x27;,</span><br><span class=\"line\">        &#x27;Referer&#x27;:&quot;https://cn.bing.com&quot;,</span><br><span class=\"line\">        &#x27;Cookie&#x27;:&quot;MUID=3B16E5B***********782&amp;t=6&quot; #填写相应的Cookie值</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    for i in range(1,int(pages)+1):</span><br><span class=\"line\">        url = &quot;https://cn.bing.com/search?q=site%3a&quot;+site+&quot;&amp;go=Search&amp;ds&amp;first=&quot;+ str((int(i)-1)*10) +&quot;&amp;FROM=PERE&quot;</span><br><span class=\"line\">        html = requests.get(url,headers=headers)</span><br><span class=\"line\">        soup = BeautifulSoup(html.content,&#x27;html.parser&#x27;)</span><br><span class=\"line\">        job_bt = soup.findAll(&#x27;h2&#x27;)</span><br><span class=\"line\">        for i in job_bt:</span><br><span class=\"line\">            link = i.a.get(&#x27;href&#x27;)</span><br><span class=\"line\">            domain = str(urlparse(link).scheme + &quot;://&quot; + urlparse(link).netloc)</span><br><span class=\"line\">            if domain in Subdomain:</span><br><span class=\"line\">                pass</span><br><span class=\"line\">            else:</span><br><span class=\"line\">                Subdomain.append(domain)</span><br><span class=\"line\">                print(domain)</span><br><span class=\"line\">if __name__ == &#x27;_main_&#x27;:</span><br><span class=\"line\">    if len(sys.argv) == 3:</span><br><span class=\"line\">        site = sys.argv[1]</span><br><span class=\"line\">        page = sys.argv[2]</span><br><span class=\"line\">    else:</span><br><span class=\"line\">        print(&quot;usage: %s baidu.com 10&quot;% sys.argv[0]) #输出帮助信息</span><br><span class=\"line\">        sys.exit(-1)</span><br><span class=\"line\">    Subdomain = bing_search(site,page)</span><br></pre></td></tr></table></figure>\n<p><strong>邮件爬取</strong></p>\n<blockquote>\n<p>在针对目标系统进行渗透的过程中，如果目标服务器安全性很高，通过服务器很难获取目标权限时，通常会采用社工的方式对目标服务进行进一步的攻击。邮件钓鱼攻击是常见的攻击方式之一。在进行钓鱼之前，需要针对目标相关人员的邮件信息进行全面采集。<br>\n此处邮件采集工具主要通过国内常见的搜索引擎（百度、Bing 等进行搜集）。针对搜索界面的相关邮件信息进行爬取、处理等操作之后。利用获得的邮箱账号批量发送钓鱼邮件，等待目标用户或者管理员点击之后执行，进而获得目标的权限<br>\n邮件采集工具所用到的库如下所示</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import sys</span><br><span class=\"line\">import getopt</span><br><span class=\"line\">import request</span><br><span class=\"line\">from bs4 import BeautifulSoup</span><br><span class=\"line\">import re</span><br></pre></td></tr></table></figure>\n<p>在程序的起始部分，在执行过程中没有发生异常时，则执行定义的 start () 函数。通过 sys.argv [] 实现外部指令的接受。其中，sys.argv [0] 表示代码本身的文件路径，sys.argv [1:] 表示从第一个命令行参数到输入的最后一个命令行参数，存储形式为 list 类型：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if __name__ == &#x27;__main__&#x27;</span><br><span class=\"line\">    #定义异常</span><br><span class=\"line\">    try:</span><br><span class=\"line\">        start(sys.argv[1:])</span><br><span class=\"line\">    except KeyboardInterrupt:</span><br><span class=\"line\">        print(&quot;interrupted by user, killing all threads...&quot;)</span><br></pre></td></tr></table></figure>\n<p>编写命令行参数处理功能。此处主要应用 getopt.getopt () 函数处理命令行参数，该函数目前有短选项和长选项两种格式。短选项格式为 &quot;-“加上单个字母选项；长选项格式为”–“加上一个单词选项。opts 为一个两元组列表，每个元素形式为”(选项串，附加参数)&quot;。当没有附加参数时，则为空串。之后通过 for 语句循环输出 opts 列表中的数值并赋值给自定义变量：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def start(argv):</span><br><span class=\"line\">    url = &quot; &quot;</span><br><span class=\"line\">    pages = &quot; &quot;</span><br><span class=\"line\">    if len(sys.argv) &lt; 2:</span><br><span class=\"line\">        print(&quot;-h 帮助信息 ;\\n&quot;)</span><br><span class=\"line\">        sys.exit()</span><br><span class=\"line\">    #定义异常处理</span><br><span class=\"line\">    try:</span><br><span class=\"line\">        bannner()</span><br><span class=\"line\">        opts,args = getopt.getopt(argv,&quot;-u;-p;-h&quot;)</span><br><span class=\"line\">    except getopt.GetoptError:</span><br><span class=\"line\">        print(&#x27;Error an argument!&#x27;)</span><br><span class=\"line\">        sys.exit()</span><br><span class=\"line\">    for opt,arg in opts:</span><br><span class=\"line\">        if opt == &quot;-u&quot;:</span><br><span class=\"line\">            url = args</span><br><span class=\"line\">        elif opt == &quot;-p&quot;:</span><br><span class=\"line\">            pages = arg</span><br><span class=\"line\">        elif opt == &quot;-h&quot;:</span><br><span class=\"line\">            print(usage())</span><br><span class=\"line\">    launcher(url,pages)</span><br></pre></td></tr></table></figure>\n<p>输出帮助信息，增加代码工具的可读性和易用性。为了使输出信息更加美观简洁，可以通过转译字符设置输出字体颜色，从而实现需要的效果，开头部分包含三个参数：显示方式、前景色、背景色。这三个参数是可选的，可以只写其中的某一参数。结尾部分可以省略，但是为了书写规范，建议以 &quot;\\033 [0m&quot; 结尾</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">开头：\\033[显示方式;前景色;背景色m]</span><br><span class=\"line\">结尾部分：\\033[0m</span><br></pre></td></tr></table></figure>\n<p>示例代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">print(&#x27;\\033[0;30;41m 你好 \\033[0m&#x27;)</span><br><span class=\"line\">print(&#x27;\\033[0;30;47m 你好 \\033[0m&#x27;)</span><br></pre></td></tr></table></figure>\n<p>输出显示：<br>\n<img data-src=\"https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/6LLEP3RsCoh5eujI.png!thumbnail\" alt=\"\" title=\"fig:\"></p>\n<p><img data-src=\"https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/amEWiG135rsDgVAA.png!thumbnail\" alt=\"\"></p>\n<p>先以图案形式输出脚本出自 MS08067 实验室，然后输出有关脚本使用的帮助信息，即可执行参数执行以及对应的功能简介</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#banner信息</span><br><span class=\"line\">def banner():</span><br><span class=\"line\">    print(&#x27;\\033[1;34m###############################################################################################\\033[0m\\n&#x27;&#x27;\\033[1;34m#############################################\\033[1;32mMS08067实验室\\033[1;34m#############################################\\033[0m\\n&#x27;&#x27;\\033[1;34m##########################################################################################################\\033[0m\\n&#x27;)</span><br><span class=\"line\">#使用规则</span><br><span class=\"line\">def usage():</span><br><span class=\"line\">    print(&#x27;-h: --help 帮助;&#x27;)</span><br><span class=\"line\">    print(&#x27;-u: --url 域名;&#x27;)</span><br><span class=\"line\">    print(&#x27;-p: --pages 页数;&#x27;)</span><br><span class=\"line\">    print(&#x27;eg:python -u &quot;www.baidu.com&quot; -p 100&#x27;+&#x27;\\n&#x27;)</span><br><span class=\"line\">    sys.exit()</span><br></pre></td></tr></table></figure>\n<p>同时也可以根据自己的喜好设置输出不同类型的字体颜色或者图案<br>\n确定搜索邮件的关键字，并调用 bing_search () 和 baidu_search () 两个函数，返回 Bing 与百度两大搜索引擎的查询结果，由获取到的结果进行列表合并，去重之后循环输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#漏洞回调函数</span><br><span class=\"line\">def launcher(url,pages):</span><br><span class=\"line\">    email_num = []</span><br><span class=\"line\">    key_words = [&#x27;email&#x27;,&#x27;mail&#x27;,&#x27;mailbox&#x27;,&#x27;邮件&#x27;,&#x27;邮箱&#x27;,&#x27;postbox&#x27;]</span><br><span class=\"line\">    for page in range(1,int(pages)+1):</span><br><span class=\"line\">        for key_word in key_words:</span><br><span class=\"line\">            bing_emails = bing_search(url,page,key_word)</span><br><span class=\"line\">            baidu_emails = baidu_search(url,page,key_word)</span><br><span class=\"line\">            sum_emails = bing_emails + baidu_emails</span><br><span class=\"line\">            for email in sum_emails:</span><br><span class=\"line\">                if email in email_num:</span><br><span class=\"line\">                    pass</span><br><span class=\"line\">                else:</span><br><span class=\"line\">                    print(email)</span><br><span class=\"line\">                    with open(&#x27;data.txt&#x27;,&#x27;a+&#x27;) as f:</span><br><span class=\"line\">                        f.write(email + &#x27;\\n&#x27;)</span><br><span class=\"line\">                    email_num.append(email)</span><br></pre></td></tr></table></figure>\n<p>用 Bing 搜索引擎进行邮件爬取。Bing 引擎具有反爬系统，会通过限定 referer、cookie 等信息来确定是否是网页爬取操作。可以通过指定 referer 与 request.session () 函数自动获取 cookie 信息，绕过 Bing 搜索引擎的防爬防护</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def bing_search(url,page,key_word):</span><br><span class=\"line\">    referer = &quot;http://cn.bing.com/search?q=email+site%3abaidu.com&amp;qs=n&amp;sp=-1&amp;pq=emailsite%3baidu.com&amp;first=1&amp;FROM=PERE1&quot;</span><br><span class=\"line\">    conn = requests.session()</span><br><span class=\"line\">    bing_url = &quot;http://cn.bing.com/search?q=&quot; + key_word + &quot;+site%3a&quot; + url + &quot;&amp;qs=n&amp;sp=-1&amp;pq=&quot; + key_word + &quot;site%3a&quot; + url + &quot;&amp;first=&quot; +str((page-1)*10) + &quot;&amp;FROM=FEERE1&quot;</span><br><span class=\"line\">    conn.get(&#x27;http://cn.bing.com&#x27;,headers=headers(referer))</span><br><span class=\"line\">    r = conn.get(bing_url,stream=True,headers=headers(referer),timeout=8)</span><br><span class=\"line\">    emails = search_email(r.text)</span><br><span class=\"line\">    return emails</span><br></pre></td></tr></table></figure>\n<p>用百度搜索引擎进行邮件爬取。同样的，百度搜索引擎也做了反爬防护，相对于 Bing 来说，百度不仅对 referer 和 cookie 进行校验，也同时在页面中通过 JavaScript 语句进行动态请求链接，从而导致不能动态获取页面中的信息。可以通过对链接的提取，再进行 request 请求，从而绕过百度搜索引擎的反爬设置</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def baidu_search(url,page,key_word):</span><br><span class=\"line\">    email_list = []</span><br><span class=\"line\">    emails = []</span><br><span class=\"line\">    referer = &quot;https://www.baidu.com/s?wd=email+site%3Abaidu.com&amp;pn=1&quot;</span><br><span class=\"line\">    baidu_url = &quot;https://www.baidu.com/s?wa=&quot;+key_word+&quot;+site%3A&quot;+url+&quot;&amp;pn=&quot;+str((page-1)*10)</span><br><span class=\"line\">    conn = requests.session</span><br><span class=\"line\">    conn.get(referer,headers=headers(referer))</span><br><span class=\"line\">    r = conn.get(baidu_url,headers=headers(referer))</span><br><span class=\"line\">    soup = BeautifulSoup(r.txt,&#x27;html&#x27;)</span><br><span class=\"line\">    tagh3 = soup.find_all(&#x27;h3&#x27;)</span><br><span class=\"line\">    for h3 in tagh3:</span><br><span class=\"line\">        href = h3.find(&#x27;a&#x27;).get(&#x27;href&#x27;)</span><br><span class=\"line\">        try:</span><br><span class=\"line\">            r = requests.get(href,headers=headers(referer),timeout=8)</span><br><span class=\"line\">            emails = search_email(r.txt)</span><br><span class=\"line\">        except Exception as e:</span><br><span class=\"line\">            pass</span><br><span class=\"line\">        for email in emails:</span><br><span class=\"line\">            email_list.append(email)</span><br><span class=\"line\">    return email_list</span><br></pre></td></tr></table></figure>\n<p>接下来通过正则表达式获取邮箱号码，此处也可换成目标企业邮箱的正则表达式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def search_email(html):</span><br><span class=\"line\">    emails = re.findall(r&quot;[a-z0-9\\.\\-+_]+@[a-z0-9\\.\\-+_]+\\.[a-z]+&quot;,html,re.I)</span><br><span class=\"line\">    return emails</span><br><span class=\"line\">def headers(referer):</span><br><span class=\"line\">    headers = &#123;&#x27;User-Agent&#x27;:&#x27;Mozilla/5.0(X11;Linux x86_64;rv:60.0) Gecko/20100101 Firefoc/60.0&#x27;,</span><br><span class=\"line\">               &#x27;Accept&#x27;:&#x27;*/*&#x27;</span><br><span class=\"line\">               &#x27;Accept-Language&#x27;: &#x27;en-US,en;q=0.5&#x27;,</span><br><span class=\"line\">               &#x27;Accept-Encoding&#x27;: &#x27;gzip,deflate&#x27;,</span><br><span class=\"line\">               &#x27;Referer&#x27;:referer</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">    return headers</span><br></pre></td></tr></table></figure>\n<p>用 python3 执行脚本，-u 参数指定域名，-p 参数指定搜索引擎的页数，如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python3 ce.py -u &quot;baidu.com&quot; -p 1</span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "python"
            ]
        },
        {
            "id": "https://nnnpc.github.io/2024/04/16/Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/",
            "url": "https://nnnpc.github.io/2024/04/16/Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/",
            "title": "Socket网络编程",
            "date_published": "2024-04-16T05:58:19.031Z",
            "content_html": "<blockquote>\n<p>Socket 是计算机之间进行网络通信的一套程序接口，相当于在发送端和接收端之间建立了一个通信管道。在实际应用中，一些远程管理软件和网络安全软件大多依赖于 Socket 来实现特定功能，由于 TCP（Transmission<br>\nControl<br>\nProtocol，传输控制协议）方式在网络编程中应用得非常频繁，此处将对 TCP 编程进行讲解并给出具体应用实例<br>\n编写 TCP 时一般会用到的 Socket 模块，其方法主要包括：</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">connect(address)：连接远程计算机</span><br><span class=\"line\">send(bytes[,flags])：发送数据</span><br><span class=\"line\">recv(bufsize[,flags])：接收数据</span><br><span class=\"line\">bind(address)：绑定地址</span><br><span class=\"line\">listen(backlog)：开始监听，等待客户端连接</span><br><span class=\"line\">accept()：响应客户端的一个请求，接受一个连接</span><br></pre></td></tr></table></figure>\n<p>使用 TCP 进行通信，首先需要的是在客户端和服务端之间建立连接，并且要在通信结束后关闭连接以释放资源。由于 TCP 是面向连接的，因此相对于 UDP 来说能提供更高的可靠性。<br>\n用示例展示如何通过 TCP 进行通信：</p>\n<blockquote>\n<p>设计一个对话系统 &quot;小艾&quot;。该应用分为两部分，一部分为服务端，另一部分为客户端。客户端发送请求信息，服务端返回应答信息。</p>\n</blockquote>\n<p><strong>1. 服务端代码（<span class=\"exturl\" data-url=\"aHR0cDovL3NlcnZlci5weQ==\">server.py</span>）：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import socket</span><br><span class=\"line\"></span><br><span class=\"line\">language = &#123;&#x27;what is your name:&#x27;:&#x27;I am Tom&#x27;,&#x27;how old are you?&#x27;:&#x27;25&#x27;,&#x27;bye&#x27;:&#x27;bye!&#x27;&#125;</span><br><span class=\"line\">HOST = &quot;127.0.0.1&quot;</span><br><span class=\"line\">PORT = 6666</span><br><span class=\"line\">s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class=\"line\">s.bind((HOST,PORT))</span><br><span class=\"line\">s.listen(1)</span><br><span class=\"line\">print(&quot;Listing at port 6666&quot;)</span><br><span class=\"line\">conn,addr = s.accept()</span><br><span class=\"line\">print(&quot;connect by:&quot;,addr)</span><br><span class=\"line\">while True:</span><br><span class=\"line\">    data = conn.recv(1024)</span><br><span class=\"line\">    data = data.decode()</span><br><span class=\"line\">    if not data:</span><br><span class=\"line\">        break</span><br><span class=\"line\">    print(&#x27;received message:&#x27;,data)</span><br><span class=\"line\">    conn.sendall(language.get(data,&#x27;Nothing&#x27;).encode())</span><br><span class=\"line\">conn.close()</span><br><span class=\"line\">s.close()</span><br></pre></td></tr></table></figure>\n<p><strong>2. 客户端代码（<span class=\"exturl\" data-url=\"aHR0cDovL2NsaWVudC5weQ==\">client.py</span>）：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import socket,sys</span><br><span class=\"line\">host = &quot;127.0.0.1&quot;</span><br><span class=\"line\">port = 6666</span><br><span class=\"line\">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class=\"line\">try:</span><br><span class=\"line\">    s.connect((host,port))</span><br><span class=\"line\">except Exception as e:</span><br><span class=\"line\">    sys.exit()</span><br><span class=\"line\">while True:</span><br><span class=\"line\">    c = input(&quot;YOU SAY:&quot;)</span><br><span class=\"line\">    s.sendall(c.encode())</span><br><span class=\"line\">    data = s.recv(1024)</span><br><span class=\"line\">    data = data.decode()</span><br><span class=\"line\">    print(&#x27;Recived:&#x27;, data)</span><br><span class=\"line\">    if c.lower() == &#x27;再见&#x27;:</span><br><span class=\"line\">        break</span><br><span class=\"line\">s.close()</span><br></pre></td></tr></table></figure>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL3huLS1zZXJ2ZXItOW83aXltdTRjc2E3MjlmeW1hOTVyMXRidDc1ZHZoM2gueG4tLXB5Y2xpZW50LTBjMm4ucHk=\">将以上代码分别命名为 server.py 和 client.py</span>，在 cmd 窗口运行服务端程序，服务端开始进行监听；启动一个新的 cmd 窗口并运行客户端程序，服务端程序提示连接已建立；在客户端输入要发送的信息，服务端会根据提前建立的字典自动进行回复<br>\n效果图：</p>\n<p><img data-src=\"https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/dm9eyFiA0r6OHqQy.png!thumbnail\" alt=\"\"></p>\n<p>在运行客户端代码后，服务端会显示已连接 ip 和端口，并且会显示出接收的语句，当输入 &quot;再见&quot; 时，服务端和客户端会同时断开，是因为 client.py 中 while 循环中的 if 语句，当输入再见时会执行 break 语句跳出循环，并执行 s.close () 关闭程序，从而与服务端断开连接，服务端也就断开了</p>\n",
            "tags": [
                "python"
            ]
        },
        {
            "id": "https://nnnpc.github.io/2024/04/16/Python%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%BB%93%E6%9E%84/",
            "url": "https://nnnpc.github.io/2024/04/16/Python%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%BB%93%E6%9E%84/",
            "title": "Python学习------异常处理结构",
            "date_published": "2024-04-16T05:58:19.026Z",
            "content_html": "<blockquote>\n<p>对于每一种高级语言来说，异常处理结构不仅能够提高代码的鲁棒性，而且提高了代码的容错性，从而不会因为使用者的错误输入而造成系统崩溃，也可以通过异常处理结构为使用者提供更加友好的错误提示。引发程序异常的原因有很多种，较为常见的有除 0、下标越界等。<br>\npython 中提供了很多种不同形式的异常处理结构，其基本思路都是先尝试执行代码，再处理可能发生的错误</p>\n</blockquote>\n<p><strong>1.try…except… 结构</strong></p>\n<p>在 python 异常处理结构中，try…except… 结构使用的最为频繁，其中 try 子句中的代码块为可能引发异常的语句，except 子句用来捕获相应的异常。可以理解为：当 try 子句代码块执行异常并且被 except 子句捕获的时候，执行 except 子句的代码块</p>\n<p>例：记录学生数学成绩，范围为 0~100 的整形数值，如超出范围则会有提示</p>\n<p>代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">score = input(&#x27;数学成绩：&#x27;)</span><br><span class=\"line\">try:</span><br><span class=\"line\">    score = int(score)</span><br><span class=\"line\">    if(0&lt;score&lt;=100):</span><br><span class=\"line\">        print(&quot;数学成绩为：&quot;,score)</span><br><span class=\"line\">    else:</span><br><span class=\"line\">        print(&quot;超出最大范围&quot;)</span><br><span class=\"line\">except Exception as e:</span><br><span class=\"line\">    print(&quot;输入错误！&quot;)</span><br></pre></td></tr></table></figure>\n<p>输入：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">80</span><br><span class=\"line\">120</span><br><span class=\"line\">a</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">数学成绩为： 80</span><br><span class=\"line\">超出最大范围</span><br><span class=\"line\">输入错误！</span><br></pre></td></tr></table></figure>\n<p>这里刚开始我做转化成 int 型是在输入时直接进行转化了，比较呆，因此直接报出了错误，原理就是在输入的时候检测到了 a 不是整型数，且输入并没有在 try 语句当中，自然不会进行异常处理（就这个例题来说，异常处理的便是输入的不是整形的数值），因此直接报错。解决的办法便是将强制转换放入到 try 语句当中（如上代码），或者将强制转换的输入放入到 try 语句当中，就能进行异常处理了<br>\n<strong> 2.try…except…else… 结构</strong></p>\n<p>该结构其实可以理解为结构 1<br>\ntry…except… 结构的改版，解释为：如果 try 语句中抛出异常被 except 捕获，则执行相应的异常处理代码，如果没有抛出异常，则执行 else 语句中的代码。相当于将有可能抛出异常的代码放入 try 中，而其它的代码放入 else 中，两者分离</p>\n<p>代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">try:</span><br><span class=\"line\">    score = int(input(&#x27;数学成绩：&#x27;))</span><br><span class=\"line\">except Exception as e:</span><br><span class=\"line\">    print(&quot;输入错误！&quot;)</span><br><span class=\"line\">else:</span><br><span class=\"line\">    if(0&lt;score&lt;=100):</span><br><span class=\"line\">        print(&quot;数学成绩为：&quot;,score)</span><br><span class=\"line\">    else:</span><br><span class=\"line\">        print(&quot;超出最大范围&quot;)</span><br></pre></td></tr></table></figure>\n<p>输入：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">80</span><br><span class=\"line\">120</span><br><span class=\"line\">a</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">数学成绩为： 80</span><br><span class=\"line\">超出最大范围</span><br><span class=\"line\">输入错误！</span><br></pre></td></tr></table></figure>\n<p><strong>3.try…except…finally… 结构</strong></p>\n<blockquote>\n<p>在该结构中，无论 try 子句是否正常执行，finally 子句中的代码块总会得到执行。在日常开发过程中，该结构通常用来做清理工作。释放 try 子句中申请的资源<br>\n例：输入两个数值 a，b 进行除法运算，并输出最终的结果（要求带有异常处理结构）</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = int(input(&#x27;a:&#x27;))</span><br><span class=\"line\">b = int(input(&#x27;b:&#x27;))</span><br><span class=\"line\">try:</span><br><span class=\"line\">    div = a/b</span><br><span class=\"line\">    print(div)</span><br><span class=\"line\">except Exception as e:</span><br><span class=\"line\">    print(&#x27;The second parameter cannot be 0&#x27;)</span><br><span class=\"line\">finally:</span><br><span class=\"line\">    print(&#x27;运行结束！&#x27;)</span><br></pre></td></tr></table></figure>\n<p>输入：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a:1</span><br><span class=\"line\">b:5</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0.2</span><br><span class=\"line\">运行结束！</span><br></pre></td></tr></table></figure>\n<p>当 b 为 0 即分母为 0 时发生异常，能被 except 捕获并输出<br>\n The second parameter cannot be 0</p>\n<p>输入：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a:1</span><br><span class=\"line\">b:0</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">The second parameter cannot be 0</span><br><span class=\"line\">运行结束！</span><br></pre></td></tr></table></figure>\n<p>try…except…finally… 结构可以理解为 finally 就是为了确保设计程序时没有考虑到的异常处理而导致程序不能被完整的运行完并且进行清理，类似于文件处理时的 f.close ()，起到一个收尾的作用，无论是否异常都会执行该代码块</p>\n",
            "tags": [
                "python"
            ]
        },
        {
            "id": "https://nnnpc.github.io/2024/04/16/Python%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%BA%8F%E5%88%97/",
            "url": "https://nnnpc.github.io/2024/04/16/Python%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%BA%8F%E5%88%97/",
            "title": "Python学习------序列",
            "date_published": "2024-04-16T05:58:19.024Z",
            "content_html": "<h1 id=\"一-列表\"><a class=\"markdownIt-Anchor\" href=\"#一-列表\">#</a> 一。列表</h1>\n",
            "tags": [
                "python"
            ]
        },
        {
            "id": "https://nnnpc.github.io/2024/04/16/Python%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/",
            "url": "https://nnnpc.github.io/2024/04/16/Python%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/",
            "title": "Python学习------文件处理",
            "date_published": "2024-04-16T05:58:19.023Z",
            "content_html": "<blockquote>\n<p>文件就像一个仓库，可以存储各种类型的数据。根据用途可以将文件分为数据库文件、图像文件、音频文件、视屏文件、文本文件等。<br>\n<strong>文本文件</strong></p>\n</blockquote>\n<p>在文本文件中存储的是常规字符串，由文本行组成，每行通常由换行符 &quot;\\n&quot; 结尾</p>\n<p>对于文本文件来说，通常的操作流程为打开文件并创建对象，对该文件内容进行读取、写入、删除、修改等操作，关闭并保存文件</p>\n<p><strong>打开并创建对象</strong></p>\n<p>在 python 中内置了文件对象，通过 open () 函数就可以指定模式打开指定文件，并创建文件对象</p>\n<p>该函数格式如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">open(file[,mode=&#x27;r&#x27;[,buffering=-1]])</span><br></pre></td></tr></table></figure>\n<p>其中各个参数意义如下：</p>\n<blockquote>\n<p><strong>file</strong>：指定要打开或者创建的文件的名称，如果该文件不存在于当前目录中，则需要明确指出绝对路径。<br>\n<strong>mode</strong>：指定打开文件后的处理方式，其中包括读模式、写模式、追加模式、二进制模式、文本模式、读写模式等<br>\n **buffering：** 指定读写文件的缓冲模式，数值为 0 表示不缓存，数值为 1 表示使用行缓存模式，数值大于 1 表示缓冲区的大小，默认值为 - 1。二进制文件和非交互文本文件以固定大小的块为缓冲单位，等价于 io<br>\n<strong> 对文件内容进行操作</strong></p>\n</blockquote>\n<p>对文件内容进行的操作包括：文件的读取、写入、追加，以及设置采用二进制模式、文本模式、读写模式等</p>\n<p>(1) 向文本文件中写入内容</p>\n<p>如果需要向文本文件中写入内容，在打开文件时就需要指定文件的打开模式为写模式</p>\n<p>应根据不同的需求选取不同的写入模式：</p>\n<blockquote>\n<p><strong>w</strong>：写入模式。如果文件已存在，则先清空文件内容；如果文件不存在，则创建文件<br>\n<strong> x</strong>：写入模式。创建新文件，如果文件已存在，则抛出异常<br>\n<strong> a</strong>：追加模式。也是写入模式的一种，不覆盖文件的原始内容<br>\n例如创建一个 demo 文件并写入 &quot;Hello world&quot;</p>\n</blockquote>\n<p>代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s = &quot;Hello world&quot;</span><br><span class=\"line\">f = open(&#x27;demo.txt&#x27;,&#x27;w&#x27;)</span><br><span class=\"line\">f.write(s)</span><br><span class=\"line\">f.close()</span><br></pre></td></tr></table></figure>\n<p>运行之后能发现路径下出现一个 demo.txt，里面便是 Hello world<br>\n<img data-src=\"https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/eqWX5SEffL3F8QYT.png!thumbnail\" alt=\"\" title=\"fig:\"></p>\n<p>再例如，在已经存在的 demo.txt 中写入 Hello<br>\nChina，并且不清空原始内容，则可以使用追加模式，即用 a 模式打开文件</p>\n<p>代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s = &quot;Hello China&quot;</span><br><span class=\"line\">f = open(&#x27;demo.txt&#x27;,&#x27;a&#x27;)</span><br><span class=\"line\">f.write(s)</span><br><span class=\"line\">f.close()</span><br></pre></td></tr></table></figure>\n<p>打开 txt，发现追加成功<br>\n<img data-src=\"https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/xLGvQJeFMjzZUjP6.png!thumbnail\" alt=\"\" title=\"fig:\"></p>\n<p>(2) 读取文件中的内容</p>\n<p>有时需要加载文本中的某行或者全部内容，就需要用到读取操作</p>\n<blockquote>\n<p><strong>r</strong>：读模式（默认模式，可以省略），如果文件不存在，则抛出异常<br>\n<strong> +</strong>：读写模式（可与其他模式组合使用）<br>\n例如读取 demo.txt 中的第一行的操作：</p>\n</blockquote>\n<p>代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f = open(&#x27;demo.txt&#x27;,&#x27;r&#x27;)</span><br><span class=\"line\">print(f.readline())</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hello worldHello China</span><br></pre></td></tr></table></figure>\n<p>手动在 demo.txt 中换行添加内容，这里直接添加 111111111<br>\n 代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f = open(&#x27;demo.txt&#x27;,&#x27;r&#x27;)</span><br><span class=\"line\">print(f.read())</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hello worldHello China</span><br><span class=\"line\">111111111</span><br></pre></td></tr></table></figure>\n<p><strong>关闭文件对象</strong><br>\n当操作完文件内容之后，一定要关闭文件对象，这样才能确保所作的修改都保存到了文件当中</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f.close()</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>文件操作基本遵循 &quot;打开 -&gt; 读写 -&gt; 关闭&quot; 的流程，但是如果文件读写操作代码引发了异常，就很难保证文件能够被正常关闭。可以使用上下文管理关键字 with 来避免产生这个问题。with 能够自动管理资源，总能保证文件正确关闭，并且可以在代码执行结束后自动还原开始执行代码块时的现场<br>\n代码：</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b = &#x27;bbb&#x27;</span><br><span class=\"line\">with open(&#x27;demo.txt&#x27;,&#x27;a&#x27;) as f:</span><br><span class=\"line\">    f.write(b)</span><br></pre></td></tr></table></figure>\n<p>查看 demo.txt 成功添加<br>\n另外可以指定是以文本模式还是二进制模式进行处理</p>\n<blockquote>\n<p>“t” - 文本 - 默认值。文本模式。<br>\n“b” - 二进制 - 二进制模式（例如图像）。<br>\n这些知道了就可以来进行一下实战应用，可以看下 misc 比较常见的考点，16 进制的翻转</p>\n</blockquote>\n<p>先拿一张正常的图片</p>\n<p><img data-src=\"https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/jbUQT3ZTSfYKV1lE.png!thumbnail\" alt=\"\"></p>\n<p>用 winhex 来查看下图片的头和尾</p>\n<p><img data-src=\"https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/djMYwjK7xhMXexxm.png!thumbnail\" alt=\"\"></p>\n<p><img data-src=\"https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/oskErrn7f27uZDnJ.png!thumbnail\" alt=\"\"></p>\n<p>发现都是没有问题的，那就开始使用 python 进行翻转</p>\n<p>首先我们先以二进制形式打开读取这张图片，将其存入到变量 x 中</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">with open(&#x27;cat.jpg&#x27;,&#x27;rb&#x27;) as f:</span><br><span class=\"line\">    x = f.read()</span><br></pre></td></tr></table></figure>\n<p>再对存入 x 中的内容进行翻转，将其存入到变量 re 中</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">re = x[::-1]</span><br></pre></td></tr></table></figure>\n<p>最后以二进制的形式创建打开写入一个 new 文件中</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">with open(&#x27;new&#x27;,&#x27;wb&#x27;) as f:</span><br><span class=\"line\">    f1.write(re)</span><br></pre></td></tr></table></figure>\n<p>这样就实现了图片的 16 进制翻转，将 new 文件拖入 winhex 查看一下头尾<br>\n<img data-src=\"https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/jX7EwrXUvU1AcmOm.png!thumbnail\" alt=\"\" title=\"fig:\"></p>\n<p><img data-src=\"https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/uQ6CBEa7uJdNFDad.png!thumbnail\" alt=\"\"></p>\n<p>按 16 进制位成功翻转，如果想实现将 16 进制数值从头到尾全部翻转的话可以将图片的 16 进制进行复制使用文本形式打开文件，这里将 16 进制存入 re.txt 中</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">with open(&#x27;re.txt&#x27;,&#x27;r&#x27;) as f:</span><br><span class=\"line\">    x = f.read()</span><br></pre></td></tr></table></figure>\n<p>同样进行翻转</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">re = x[::-1]</span><br></pre></td></tr></table></figure>\n<p>这里的写入需要注意一个问题，可能会报错</p>\n<blockquote>\n<p>TypeError: a bytes-like object is required, not ‘str’<br>\n当文本写成一个文件的时候是需要将 str 类型的数据转换为 byte 类型的数据的，因此，在写入的时候需要加上类型的转换</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">with open(&#x27;new&#x27;,&#x27;wb&#x27;) as f1:</span><br><span class=\"line\">    f1.write(bytes.fromhex(re))</span><br></pre></td></tr></table></figure>\n<p>再来看看 new 文件的 16 进制头尾<br>\n<img data-src=\"https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/esDXQupsJSzV5llx.png!thumbnail\" alt=\"\" title=\"fig:\"></p>\n<p><img data-src=\"https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/2V75YrGcY54SzRfY.png!thumbnail\" alt=\"\"></p>\n<p>发现确实是一种文本格式的翻转了，而不是 16 进制位的翻转</p>\n<p>同样的，将该代码以同样的形式可以翻转成为一张正常的图片</p>\n<p>代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">with open(&#x27;re.txt&#x27;,&#x27;r&#x27;) as f:</span><br><span class=\"line\">    x = f.read()</span><br><span class=\"line\">    re = x[::-1]</span><br><span class=\"line\">with open(&#x27;new.jpg&#x27;,&#x27;wb&#x27;) as f:</span><br><span class=\"line\">    f1.write(bytes.fromhex(re))</span><br></pre></td></tr></table></figure>\n<p><img data-src=\"https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/xmyjyH0IvPFoDDAC.png!thumbnail\" alt=\"\"></p>\n<p>成功还原小猫的图片</p>\n",
            "tags": [
                "python"
            ]
        },
        {
            "id": "https://nnnpc.github.io/2024/04/16/Python%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/",
            "url": "https://nnnpc.github.io/2024/04/16/Python%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/",
            "title": "Python学习------控制结构",
            "date_published": "2024-04-16T05:58:19.021Z",
            "content_html": "<blockquote>\n<p>常见的编程语言通常包含三大控制结构：顺序结构、选择结构和循环结构。其中，顺序结构就是一句跟着一句执行。而选择结构则是通过条件判断，最终选择出所需要的结果。循环结构时通过重复有规律性的操作，从而减少代码量，使代码表达更为简洁。<br>\n<strong>选择结构</strong></p>\n</blockquote>\n<p>在编程时，当需要根据条件表达式的值确定下一步的执行流程时，通常会用到选择结构，最为常用的选择结构语句是 if 语句</p>\n<p>输入：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = 1</span><br><span class=\"line\">if(a&gt;0):</span><br><span class=\"line\">    print(a)</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br></pre></td></tr></table></figure>\n<p>有时会希望输出自己所设定的一句话或者是某个提示，例如经典的学生成绩的优秀、良好和不及格，分为小于六十、大于等于六十小于八十、大于等于八十三个分段<br>\n代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">score = int(input())</span><br><span class=\"line\">if (score &lt; 60):</span><br><span class=\"line\">    print(&quot;不及格&quot;)</span><br><span class=\"line\">if (60&lt;=score&lt;80):</span><br><span class=\"line\">    print(&quot;良好&quot;)</span><br><span class=\"line\">if (score&gt;=80):</span><br><span class=\"line\">    print(&quot;优秀&quot;)</span><br></pre></td></tr></table></figure>\n<p>输入：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">100</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">优秀</span><br></pre></td></tr></table></figure>\n<p>输入：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">59</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">不及格</span><br></pre></td></tr></table></figure>\n<p><strong>循环结构</strong><br>\n在 python 中主要有两种类型的循环结构：for 循环和 while 循环，for 循环一般用于有明显边界范围的情况，例如从 1 加到 100。而 while 循环一般用于循环次数难以确定的情况下</p>\n<p><strong>for 循环：</strong></p>\n<p>求 1+2+3+…+100</p>\n<p>代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sum = 0</span><br><span class=\"line\">for i in range(1,101):</span><br><span class=\"line\">    sum += i</span><br><span class=\"line\">print(sum)</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5050</span><br></pre></td></tr></table></figure>\n<p><strong>while：</strong><br>\n求解 1+2+3+…+x，x 为输入的变量</p>\n<p>这里可以将 x 作为第一个值，从 x 进行倒序相加，判断条件为 x!=0 这样就能实现不确定的输入数值加到一的程序</p>\n<p>代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = int(input())</span><br><span class=\"line\">sum = 0</span><br><span class=\"line\">while x != 0:</span><br><span class=\"line\">    sum = sum + x</span><br><span class=\"line\">    x = x-1</span><br><span class=\"line\">print(sum)</span><br></pre></td></tr></table></figure>\n<p>输入：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">100</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5050</span><br></pre></td></tr></table></figure>\n<p>输入：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">50</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1275</span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "python"
            ]
        },
        {
            "id": "https://nnnpc.github.io/2024/04/16/Pocsuite%E6%A1%86%E6%9E%B6/",
            "url": "https://nnnpc.github.io/2024/04/16/Pocsuite%E6%A1%86%E6%9E%B6/",
            "title": "Pocsuite框架",
            "date_published": "2024-04-16T05:58:19.019Z",
            "content_html": "<blockquote>\n<p>在渗透测试过程中，会面对大量的渗透概念验证（Proof of<br>\nConcept，POC）和漏洞利用（Exploit，EXP），从中查找所需要的对应脚本非常困难，而渗透测试框架的出现解决了这一问题，在编写时就将 POC 和 EXP 按照一定的格式进行限制，按照文件夹或文件名进行分类，并内置了许多可调用的模块，以便于 POC 和 EXP 的快速编写。<br>\n常见的渗透测试框架包括 Metasploit、Pocsuite、Fsociety 等，这里主要介绍 Pocsuite 渗透测试框架的使用及编写</p>\n</blockquote>\n<p><strong>1.Pocsuite 框架</strong></p>\n<blockquote>\n<p>Pocsuite 是一款基于漏洞与 POC 的远程漏洞验证框架，支持 Windows/Linux/Mac<br>\nOS<br>\nX 等系统，整个框架操作灵活，既方便了对漏洞的管理、查找等，也提高了工作效率。<br>\n先了解两个基本概念：POC，是用来验证漏洞是否存在的一段代码；EXP，指利用系统漏洞进行渗透。先有 POC，后有 EXP。<br>\n你可以直接使用 Pocsuite 进行漏洞的验证与利用，也可以基于 Pocsuite 进行 POC/EXP 的开发，因为 Pocsuite 同时也是一个 POC 开发框架。你还可以在漏洞测试工具里直接集成 Pocsuite，因为 Pocsuite 也提供标准的调用类</p>\n</blockquote>\n<p><strong>功能介绍</strong></p>\n<p><strong>漏洞测试框架</strong></p>\n<p>Pocsuite 用 Python3 编写，支持验证、利用及壳三种插件模式，你可以指定单个目标或者从文件中导入多个目标，使用单个 POC 或者 POC 集合进行漏洞的验证或利用。可以使用命令行模式进行调用，也支持类似 Metaspolit 的交互模式进行处理，除此之外，还包含了一些基本功能，如输出结果报告等</p>\n<p><strong>POC/EXP 开发包</strong></p>\n<p>Pocsuite<br>\n3 也是一个 POC/EXP 的 SDK（也就是开发包），封装了一些基础的 POC 类以及一些常用的方法，比如 Webshell 的相关方法，基于 Pocsuite<br>\n3 进行 POC/EXP 的开发，只需要编写最核心的漏洞验证部分代码，而不用去关心整体的结果输出等其他一些处理。基于 Pocsuite<br>\n3 编写的 POC/EXP 可以直接呗 Pocsuite 使用，Seebug 网站也有几千个基于 Pocsuite 的 POC/EXP</p>\n<p><strong>可被集成模块</strong></p>\n<p>Pocsuite<br>\n3 除了本身是一个安全工具，也可以作为一个 Python 包被集成进漏洞测试模块。还可基于 Pocsuite<br>\n3 开发自己的应用，在 Pocsuite<br>\n3 里封装了可以被其他程序导入的 POC 调用类，你可以基于 Pocsuite<br>\n3 进行二次开发，调用 Pocsuite 3 开发自己的漏洞验证工具</p>\n<p><strong>集成 ZoomEye、Seebug、Ceye</strong></p>\n<p>Pocsuite 3 还集成了 ZoomEye、Seebug 和 Ceye API，你可以利用 ZoomEye<br>\nAPI 批量获取指定条件的测试目标（使用 ZoomEye 的 Dork 进行搜索），同时通过 Seebug<br>\nAPI 读取指定组件或者类型的漏洞的 POC 或者本地 POC，进行自动化的批量测试。也可以利用 Ceye 验证盲打的 DNS 和 HTTP 请求</p>\n<p><strong>安装</strong></p>\n<blockquote>\n<p>Pocsuite 的安装十分便捷这里提供两种安装方法，可以根据自己主机的命令来选择适合的方法进行安装，安装完成后使用 pocsuite-version 验证安装是否成功</p>\n</blockquote>\n<p><strong>方法一：</strong></p>\n<p>使用下面命令下载最新的源代码 zip 包，并以解压的方式进行安装，如下所示</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://github.com/knownsec/pocsuite3/archive/master.zip</span><br><span class=\"line\">unzip master.zip</span><br></pre></td></tr></table></figure>\n<p>回显如图所示：<br>\n<img data-src=\"https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/pITYUVlhx0BFePPS.png!thumbnail\" alt=\"\" title=\"fig:\"></p>\n<p>安装依赖：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip3 install requests requests-toolbelt </span><br><span class=\"line\">pip3 install pyreadline </span><br><span class=\"line\">pip3 install colorlog </span><br><span class=\"line\">pip3 install faker</span><br></pre></td></tr></table></figure>\n<p>其实就是缺什么装什么，看清楚报错，安装需要的东西即可（以上是我遇到的）安装好后进入 pocsuite3-master/pocsuite3 文件夹输入如下命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python3 cli.py -h</span><br></pre></td></tr></table></figure>\n<p>如果显示正常则如下图所示：</p>\n<p><img data-src=\"https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/sewas5uzlj04cLBH.png!thumbnail\" alt=\"\"></p>\n<p><strong>方法二：</strong></p>\n<p>直接使用 pip 命令安装方式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install pocsuite3</span><br><span class=\"line\">或者</span><br><span class=\"line\">pip3 install -U pocsuite3 --no-cache-dir </span><br></pre></td></tr></table></figure>\n<p>当报错需要更新你的 pip 时也可以使用语句</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apt-get install python3-pip </span><br></pre></td></tr></table></figure>\n<p>安装完成后需要在 Pocsuite 文件夹内直接输入命令检查安装版本</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pocsuite -version</span><br></pre></td></tr></table></figure>\n<p>结果：<br>\n<img data-src=\"https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/C3WtqtE0AdZnyN32.png!thumbnail\" alt=\"\" title=\"fig:\"></p>\n<p>个人习惯是 pip 安装会舒服一些也方便一些</p>\n<p><strong>使用方法</strong></p>\n<blockquote>\n<p>Pocsuite 具有两种交互模式，一种是命令行模式，类似于我们熟悉的 sqlmap 的交互方式，另一种是控制台交互模式，类似于 w3af 或者 Metasploit 的界面<br>\n在使用 Pocsuite 时，我们可以使用<br>\n–verify 参数来调用<em> verify 方法，用于验证目标是否存在漏洞；用<br>\n–attack 参数调用</em> attack 方法，用来向目标发起攻击</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def _attack(self):</span><br><span class=\"line\">  result = &#123;&#125;</span><br><span class=\"line\">  #write your code here</span><br><span class=\"line\">  return self.parse_output(result)</span><br><span class=\"line\">  </span><br><span class=\"line\">def _verify(self):</span><br><span class=\"line\">  result = &#123;&#125;</span><br><span class=\"line\">  #write your code here</span><br><span class=\"line\">  return self.parse_output(result)</span><br></pre></td></tr></table></figure>\n<p>1.Verify 验证模式，验证目标是否存在漏洞。-r 为脚本路径，-u 为目标地址，命令为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pocsuite -r pocs/test.py(poc脚本路径) -u (目标地址) --verify</span><br></pre></td></tr></table></figure>\n<p>2. 批量验证，将需要验证的所有目标 IP 写到一个 txt 文件中批量利用，命令为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pocsuite -r pocs/test.py(poc脚本路径) -f url.txt --verify</span><br></pre></td></tr></table></figure>\n<p>3. 加载文件夹下的所有 poc 对目标进行测试，-r 为文件夹下路径，命令为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pocsuite -r pocs/*(poc脚本路径) -u (目标地址) --verify</span><br></pre></td></tr></table></figure>\n<p>4. 使用多线程。–threads 表示线程数，在多目标场景下，可以使用该参数提高效率，命令为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pocsuite -r pocs/test.py(poc脚本路径) -u (目标地址) --verify --threads 10</span><br></pre></td></tr></table></figure>\n<p>5. 使用 Zoomeye 搜索引擎，搜索开放端口为 6379 的 Redis 服务，命令为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python3 cli.py --dork &#x27;port:6379&#x27; --vul-keyword &#x27;redis&#x27; --max-page 2</span><br></pre></td></tr></table></figure>\n<p>6.Attack 模式，向目标发起有效攻击，命令为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pocsuite -r pocs/test.py(poc脚本路径) -u (目标地址) --attack</span><br></pre></td></tr></table></figure>\n<p>7. 使用 shell 交互式模式，对目标进行远程控制，命令为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pocsuite -r pocs/test.py(poc脚本路径) -u (目标地址) --shell</span><br></pre></td></tr></table></figure>\n<p>8. 使用自定义命令’command’，调用外部传递参数，进行半交互式命令执行，命令为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pocsuite -r pocs/test.py(poc脚本路径) -u (目标地址) --attack --command &quot;whoami&quot;</span><br></pre></td></tr></table></figure>\n<p>Pocsuite 框架有利于 POC/EXP 的快速编写，并且内置的许多模块能更好地帮助渗透，比如批量 poc 测试 / 打批量目标。可以使用内置工具来进行搜索特定条件的目标等等。对于 Pocsuite 框架还不是太熟悉，需要进一步地去使用和研究才能获得更多更好的感悟</p>\n",
            "tags": [
                "python"
            ]
        }
    ]
}